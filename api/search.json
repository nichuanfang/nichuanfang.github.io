[{"id": "b9663f58f18133b35bfe243f3e916a80", "title": "Hello World", "content": "\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer introubleshooting or you can ask me on GitHub.\n1. 快速开始创建新文档hexo new &quot;My New Post&quot;\n\nMore info: Writing\n启动本地服务hexo server\n\nMore info: Server\n构建静态文件hexo generate\n\nMore info: Generating\n部署hexo deploy\n\nMore info: Deployment\n2. Markdown 自定义容器所有的自定义容器都使用这种格式:\n:::[type] [title]\n文本内容\n:::\n\n\ntype 是容器的类型\ntitle 是可选的,可以用来重命名容器的标题\n\nTip 容器:::tip\nNormal Tips Container\n:::\n\n\n如果你不想使用默认的标题 TIP，你可以使用以下方法重命名你的容器标题:\n:::tip Custom header\n\nCustom header\n\n- tips content\n- tips new line\n\n:::\n\n\nWarning 容器:::warning\nWarning!!!\n:::\n\n\nDanger 容器:::danger\nDanger!!!\n:::\n\n\nDetails 容器这是一种特殊类型的容器。如果你看过 GitHub 中的 details 容器，你可能会猜出它的功能是什么。\n是的，您可以隐藏某些内容，并单击来展开它。\n:::details Click to see more\n\nFusce rutrum venenatis eros in hendrerit. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nullam eget risus egestas, aliquet ipsum sed, volutpat tortor. Proin finibus tortor ac mauris finibus rutrum. Nullam tincidunt arcu eu urna ullamcorper, eu ultricies turpis ornare. Morbi id sollicitudin orci. Proin lobortis vehicula nibh a ornare. Cras sodales eu ligula quis fermentum. Proin eu ultrices leo, quis iaculis justo. Sed dictum, nulla sit amet imperdiet commodo, libero sapien semper justo, ut lobortis elit nunc vitae ante. Nullam lobortis odio quam, ac condimentum elit posuere vitae. Sed ornare, odio et rutrum varius, lorem eros gravida urna, in pharetra sapien justo non magna.\n\n- details content\n- details new line\n\n&#96;console.log(&#39;hello world&#39;)&#96;\n\n:::\n\n关闭状态:\n\n展开状态:\n\n", "slug": "hello-world", "date": "2023-05-11 08:19:00", "categories_index": "欢迎页", "tags_index": "template", "author_index": "倪传方"}, {"id": "cb1bde52f4b0429979650f547c40a9be", "title": "jvm学习笔记之类的加载、连接与初始化", "content": "jvm学习笔记之类的加载、连接与初始化——2019-04-04类的加载、连接与初始化\n\n\n\n\n\n\n\n\n\n加载：查找并加载类的二进制数据\n连接\n验证：确保被加载类的正确性\n准备：为类的静态变量分配内存，并将其初始化为默认值\n解析：把类中的符号引用转换为直接引用\n\n\n初始化：为类的静态变量赋予正确的初始值\n\n如：Class test{     Public static int a&#x3D;1;}在test类在被加载时，静态变量a首先被分配内存，设置默认值a&#x3D;0接着在初始化过程中才被赋予正确的初始值a&#x3D;1\nJava程序对类的使用方式可分为两种\n\n\n\n\n\n\n\n\n\n主动使用被动使用\n所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们\n主动使用（七种） 创建类的实例（new一个类对象） 访问某个类或接口的静态变量，或者对该静态变量赋值（对静态变量取值赋值）助记符 getstatic  putstatic 调用类的静态方法  助记符 invokestatic 反射（如Class.forName(“com.test.Test”)） 初始化一个类的子类如：Class Parent{}Class Child extends Parent{}当子类被初始化时，同时也标记着父类的主动使用，父类也会被初始化 Java虚拟机启动时被标明为启动类的类（Java Test） JDK1.7开始提供的动态语言支持Java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化\n除了以上七种情况，其它使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化\n类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，大致上放在堆区，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构\n 加载.class文件的方式\n\n\n\n\n\n\n\n\n\n 从本地系统中直接加载（ide工作区重启加载项目即是如此） 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件（如JSP中java代码的编写，实际上是转化成了Servlet）\n（主动使用）测试代码一\npackage com.lagoon.jvm.classloder;\n\npublic class MyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyChild1.str);\n    &#125;\n&#125;\n\nclass MyParent1&#123;\n\n    public static String str&#x3D;&quot;hello world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent1 static block&quot;);\n    &#125;\n&#125;\n\nclass MyChild1 extends MyParent1&#123;\n    static &#123;\n        System.out.println(&quot;MyChild1 static block&quot;);\n    &#125;\n&#125;\n\n\n测试结果\n并没有输出MyChild1 static block这种情况称之为对MyParent1的一个主动使用，但是并没有对MyChild1进行主动使用所以并不会对MyChild1进行初始化，也就不会执行静态代码块\n测试代码二\npackage com.lagoon.jvm.classloder;\n\npublic class MyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyChild1.str2);\n    &#125;\n&#125;\n\nclass MyParent1&#123;\n\n    public static String str&#x3D;&quot;hello world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent1 static block&quot;);\n    &#125;\n&#125;\n\nclass MyChild1 extends MyParent1&#123;\n    public static String str2&#x3D;&quot;welcome...&quot;;\n    static &#123;\n        System.out.println(&quot;MyChild1 static block&quot;);\n    &#125;\n&#125;\n\n\n测试结果\n此时在MyChild1中定义了一个str2，并在main方法中调用的str2，是对MyChild类的一次主动使用，自然会初始化，自然也就会执行静态代码块，输出语句而对于为什么MyParent1也会输出语句？是因为主动使用里有一条出初始化一个类的子类，那么也就是这个父类也会被主动使用，进行一次初始化。父类会进行先行初始化\n测试总结：对于一个静态字段来说，只有直接定义了该字段的类才会被初始化当一个类在初始化时，要求其父类全部都已经初始化完毕这就是问什么输出语句有先后顺序\n有关jvm虚拟机vm设置指令\n-XX:+TraceClassLoading,用于追踪类的加载信息并打印出来\n -XX:+&lt;option&gt;，表示开启option选项\n -XX:-&lt;option&gt;，表示关闭option选项\n*-XX:&lt;option&gt;&#x3D;&lt;value&gt;，表示将option的值设置为value\n\n再新建一个测试类MyTest2\npackage com.lagoon.jvm.classloder;\n\npublic class MyTest2 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyParent2.str);\n    &#125;\n&#125;\nclass MyParent2&#123;\n    public static String str&#x3D;&quot;hello,world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent2 static block&quot;);\n    &#125;\n&#125;\n\n\n测试结果\n显而易见是在MyParent2里定义了静态字段，所以会对这个类进行初始化，运行静态代码块但是如果把\npublic static  String str&#x3D;&quot;hello,world&quot;;\n\n改成\npublic static final String str&#x3D;&quot;hello,world&quot;;\n\n加上关键字final运行结果如下\n产生这种差异的原因是\nfinal本身的作用在于str被定义以后不能再被改变，str成为常量，然而常量在编译阶段，会被直接存入到调用这个常量的方法所在类（MyTest2）的常量池中之后，MyTest2与MyParent2就没有任何的关系了\n因此本质上，调用类，也就是MyTest2，并没有直接引用到定义这个常量的类，也就是MyParent2，因此不会触发定义常量的类的初始化\n对MyTest2进行反编译后如下\n\n\n\n\n\n\n\n\n\n\n助记符：ldc表示将int，float或是String类型的常量值从常量池中推送至栈顶\n", "slug": "jvm学习笔记之类的加载、连接与初始化——2019-04-04", "date": "2021-07-09 11:39:11", "categories_index": "Java", "tags_index": "jvm", "author_index": "倪传方"}, {"id": "99f059eccc4d62d721a5fd588d745cd9", "title": "【Java】java23种设计模式案例之命令模式", "content": "【Java】java23 种设计模式案例之命令模式\n\n\n\n\n\n\n\n\n命令模式定义参考\n\n\n\n\n\n\n\n\n\n例子: 源代码\n3 种案例\n\n\n\n\n\n\n\n\n\n1.Command 案例问题描述：一个指挥官请求（命令）三连偷袭敌人代码\npackage com.lagoon.command;\n\n&#x2F;**\n * 问题描述：一个指挥官请求（命令）三连偷袭敌人\n * 这个类扮演的是接收者角色\n *&#x2F;\npublic class CompanyArmy &#123;\n\n    public void sneakAttack()&#123;\n        System.out.println(&quot;我们知道如何偷袭敌人，保证完成任务！&quot;);\n    &#125;\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 这个接口扮演的是命令接口角色\n *&#x2F;\npublic interface Command &#123;\n    public abstract void execute();\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 这个类扮演的是具体命令的角色\n *&#x2F;\npublic class ConcreteCommand implements Command&#123;\n\n    CompanyArmy companyArmy;  &#x2F;&#x2F;含有接收者的引用\n    ConcreteCommand(CompanyArmy companyArmy)&#123;\n        this.companyArmy&#x3D;companyArmy;\n    &#125;\n\n    @Override\n    public void execute() &#123;  &#x2F;&#x2F;封装着指挥官的请求\n        companyArmy.sneakAttack();  &#x2F;&#x2F;偷袭敌人\n\n    &#125;\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 这个类代表请求者，也就是指挥官的角色\n *&#x2F;\npublic class ArmySuperior &#123;\n\n    Command command;  &#x2F;&#x2F;用来存放具体命令的引用\n    public void setCommand(Command command)&#123;\n        this.command&#x3D;command;\n    &#125;\n    public void startExecuteCommand()&#123;\n        command.execute();\n    &#125;\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 该类为main方法，演示一个指挥官下发命令如何请求三连偷袭敌人\n *&#x2F;\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建接收者\n        CompanyArmy 三连&#x3D;new CompanyArmy();\n        &#x2F;&#x2F;创建具体命令并指定接收者\n        Command command&#x3D;new ConcreteCommand(三连);\n        &#x2F;&#x2F;创建请求者\n        ArmySuperior 指挥官&#x3D;new ArmySuperior();\n        &#x2F;&#x2F;下发命令\n        指挥官.setCommand(command);\n        &#x2F;&#x2F;开始执行命令\n        指挥官.startExecuteCommand();\n        &#x2F;&#x2F;执行结果：输出语句，我们知道如何偷袭敌人，保证完成任务！\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n2.Dir 命令，演示命令模式的可撤销操作问题描述：该问题描述的是请求者请求在硬盘上建立目录，还可以撤销请求，这就要求接收者不仅可以在硬盘上建立目录，也可以删除上一次请求所建立的目录代码：\npackage com.lagoon.Dir;\n\n&#x2F;**\n * 该问题描述的是请求者请求在硬盘上建立目录，还可以撤销请求，这就要求接收者不仅可以在硬盘上建立目录，也可以删除上一次请求所建立的目录\n * 该类扮演的是接收者角色，即既可以新增目录，也可以删除目录\n *&#x2F;\nimport java.io.*;\npublic class MakeDir &#123;\n    public void createDir(String name)&#123;\n        File dir&#x3D;new File(name);\n        dir.mkdir();\n    &#125;\n\n    public void deleteDir(String name)&#123;\n        File dir&#x3D;new File(name);\n        dir.delete();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Dir;\n\n&#x2F;**\n * 该类为命令接口类,代表既可以执行命令，也可以撤销收回命令\n *&#x2F;\npublic interface Command &#123;\n    public abstract void execute(String name);\n    public abstract void undo();\n&#125;\n\n\npackage com.lagoon.Dir;\n\nimport java.util.ArrayList;\n\n&#x2F;**\n *该类为具体命令类\n *&#x2F;\npublic class ConcreteCommand implements Command&#123;\n    ArrayList&lt;String&gt; dirNameList;\n    MakeDir makeDir;\n    ConcreteCommand(MakeDir makeDir)&#123;\n        dirNameList&#x3D;new ArrayList&lt;String&gt;();\n        this.makeDir&#x3D;makeDir;\n    &#125;\n    @Override\n    public void execute(String name) &#123;\n        makeDir.createDir(name);\n        dirNameList.add(name);\n\n    &#125;\n\n    @Override\n    public void undo() &#123;\n        if (dirNameList.size()&gt;0)&#123;\n            int m&#x3D;dirNameList.size();\n            String str&#x3D;dirNameList.get(m-1);\n            makeDir.deleteDir(str);\n            dirNameList.remove(m-1);\n        &#125;\n        else\n            System.out.println(&quot;没有需要撤销的操作&quot;);\n\n    &#125;\n&#125;\n\n\npackage com.lagoon.Dir;\n\n&#x2F;**\n * 该类为请求者角色\n *&#x2F;\npublic class RequestMakeDir &#123;\n    Command command;\n    public void setCommand(Command command)&#123;\n        this.command&#x3D;command;\n    &#125;\n    public void startExecuteCommand(String name)&#123;\n        command.execute(name);\n    &#125;\n    public void undoCommand()&#123;\n        command.undo();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Dir;\n\nimport java.util.Iterator;\n\n&#x2F;**\n * 该类为发射类\n *&#x2F;\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建接收者\n        MakeDir makeDir&#x3D;new MakeDir();\n        &#x2F;&#x2F;创建具体命令并指定接收者\n        Command command&#x3D;new ConcreteCommand(makeDir);\n        RequestMakeDir requestMakeDir&#x3D;new RequestMakeDir();\n        requestMakeDir.setCommand(command);\n        &#x2F;&#x2F;建立名字是java的目录\n        requestMakeDir.startExecuteCommand(&quot;java&quot;);\n        &#x2F;&#x2F;建立名字是c的目录\n        requestMakeDir.startExecuteCommand(&quot;c&quot;);\n        &#x2F;&#x2F;建立名字是c++的目录\n        requestMakeDir.startExecuteCommand(&quot;c++&quot;);\n        &#x2F;&#x2F;撤销命令，删除名字是c++的目录\n        requestMakeDir.undoCommand();\n        &#x2F;&#x2F;撤销命令，删除名字是c的目录\n        requestMakeDir.undoCommand();\n\n        &#x2F;&#x2F;查看当前列表里的目录\n        Iterator&lt;String&gt; iterator &#x3D; ((ConcreteCommand) command).dirNameList.iterator();\n        if (iterator.hasNext())&#123;\n            System.out.println(iterator.next());\n        &#125;\n\n        &#x2F;&#x2F;运行结果，输出一个列表目录，java，说明其他被撤销成功\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n3.Letter 案例问题描述：请求者可以请求只输出英文字母表，俄文字母表或 1-n 之间的偶数也可以请求三种都输出代码：\npackage com.lagoon.Letter;\n\n&#x2F;**\n * 该文件夹演示宏命令\n * 宏命令也是一个具体命令，只不过他包含了其他命令的引用\n * 执行一个宏命令，相当于执行了许多的具体命令\n * 该类为接收者角色\n * 问题描述：请求者可以请求只输出英文字母表，俄文字母表或1-n之间的偶数\n * 也可以请求三种都输出\n *&#x2F;\npublic class PrintLetter &#123;\n    public void printEnglish()&#123;\n        for (char c&#x3D;&#39;a&#39;;c&lt;&#x3D;&#39;z&#39;;c++)&#123;\n            System.out.println(&quot; &quot;+c);\n        &#125;\n    &#125;\n\n    public void printRussian()&#123;\n        for (char c&#x3D;&#39;а&#39;;c&lt;&#x3D;&#39;я&#39;;c++)&#123;\n            System.out.println(&quot; &quot;+c);\n        &#125;\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;**\n * 命令接口类\n *&#x2F;\npublic interface Command &#123;\n    public abstract void execute();\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;&#x2F;具体命令之输出英文字母表命令\npublic class PrintEnglishCommand implements Command&#123;\n    PrintLetter letter;\n\n    public PrintEnglishCommand(PrintLetter letter) &#123;\n        this.letter &#x3D; letter;\n    &#125;\n    public void execute()&#123;\n        letter.printEnglish();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;&#x2F;具体命令之输出俄文字母表\npublic class PrintRussianCommand implements Command&#123;\n    PrintLetter letter;\n\n    public PrintRussianCommand(PrintLetter letter) &#123;\n        this.letter &#x3D; letter;\n    &#125;\n\n    @Override\n    public void execute() &#123;\n        letter.printRussian();\n    &#125;\n\n&#125;\n\n\npackage com.lagoon.Letter;\n\nimport java.util.ArrayList;\n\n&#x2F;&#x2F;宏命令，执行所有命令\npublic class MacroCommand implements Command&#123;\n\n    ArrayList&lt;Command&gt; commandArrayList;  &#x2F;&#x2F;把所有的命令存进数组\n\n    public MacroCommand(ArrayList&lt;Command&gt; commandArrayList) &#123;\n        this.commandArrayList &#x3D; commandArrayList;\n    &#125;\n\n    @Override\n    public void execute() &#123;\n        for (int k&#x3D;0;k&lt;commandArrayList.size();k++)&#123;\n            Command command&#x3D;commandArrayList.get(k);  &#x2F;&#x2F;循环定位到命令\n            command.execute(); &#x2F;&#x2F;执行命令\n        &#125;\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;&#x2F;该类为请求者角色\npublic class RequestMakedir &#123;\n    Command command;\n\n    public void setCommand(Command command) &#123;\n        this.command &#x3D; command;\n    &#125;\n    public void startExecuteCommand()&#123;\n        command.execute();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\nimport java.util.ArrayList;\n\n&#x2F;&#x2F;发射类，main方法\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;Command&gt; list&#x3D; new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;创建请求者\n        RequestMakedir requestMakedir&#x3D;new RequestMakedir();\n        &#x2F;&#x2F;创建命令具体接收者\n        Command command1&#x3D;new PrintEnglishCommand(new PrintLetter());\n        Command command2&#x3D;new PrintRussianCommand(new PrintLetter());\n\n        &#x2F;&#x2F;整合命令\n        list.add(command1);\n        list.add(command2);\n\n\n        &#x2F;&#x2F;创宏命令\n        Command macroCommand&#x3D;new MacroCommand(list);\n\n        System.out.println(&quot;单独输出英文字母表:&quot;);\n        requestMakedir.setCommand(command1);\n        requestMakedir.startExecuteCommand();\n\n        System.out.printf(&quot;%n用一个宏命令输出所有:%n&quot;);\n        requestMakedir.setCommand(macroCommand);\n        requestMakedir.startExecuteCommand();\n    &#125;\n&#125;\n\n", "slug": "【Java】java23种设计模式案例之命令模式", "date": "2020-12-01 10:50:00", "categories_index": "Java", "tags_index": "设计模式", "author_index": "倪传方"}, {"id": "00fb2df139ade064036e614bfc314c4c", "title": "python学习之re模块", "content": "一、正则表达式正则表达式本身是一种小型的、高度专业化的编程语言，它并不是 Python 的一部分。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如 str 自带的方法，但功能十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。如果已经在其他语言里使用过正则表达式，只需要简单看一看就可以上手了。而在 python 中，通过内嵌集成 re 模块，程序员们可以直接调用来实现正则匹配。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。\n1.1 数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python 里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab*”如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab*?”，将找到”a”。\n1.2 反斜杠的困扰与大多数编程语言相同，正则表达式里使用\\作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符\\，那么使用编程语言表示的正则表达式里将需要 4 个反斜杠\\\\\\\\：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python 里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r&#39;\\\\&#39;表示。同样，匹配一个数字的\\\\d可以写成r&#39;\\d&#39;。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。\n1.3 匹配模式正则表达式提供了一些可用的匹配模式，比如忽略大小写、多行匹配等，这部分内容将在 Pattern 类的工厂方法 re.compile(pattern[, flags])中一起介绍。\n二、re 模块的基本使用正则表达式是用来匹配处理字符串的 python 中使用正则表达式需要引入 re 模块\nimport re  # 第一步，要引入re模块\na &#x3D; re.findall(&quot;匹配规则&quot;, &quot;这个字符串是否有匹配规则的字符&quot;)  # 第二步，调用模块函数\nprint(a)  # 以列表形式返回匹配到的字符串\n[&#39;匹配规则&#39;]\n\n^元字符\n字符串开始位置与匹配规则符合就匹配，否则不匹配\n匹配字符串开头。在多行模式中匹配每一行的开头（Python3+已经失效，配合 compile 使用）\n^元字符如果写到[]字符集里就是反取\nimport re\na &#x3D; re.findall(&quot;^匹配规则&quot;, &quot;匹配规则这个字符串是否匹配&quot;)  # 字符串开始位置与匹配规则符合就匹配，否则不匹配\nprint(a)\n#打印出 [&#39;匹配规则&#39;]\n[&#39;匹配规则&#39;]\n\n[^a-z]反取\n匹配出除字母外的字符，^元字符如果写到字符集里就是反取\nimport re\na &#x3D; re.findall(&quot;[^a-z]&quot;, &quot;匹配s规则这s个字符串是否s匹配f规则则re则则则&quot;)  # 反取，匹配出除字母外的字符\nprint(a)\nCopy[&#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;这&#39;, &#39;个&#39;, &#39;字&#39;, &#39;符&#39;, &#39;串&#39;, &#39;是&#39;, &#39;否&#39;, &#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;]\n\n$元字符\n字符串结束位置与匹配规则符合就匹配，否则不匹配\n匹配字符串末尾，在多行模式中匹配每一行的末尾\nimport re\na &#x3D; re.findall(&quot;匹配规则$&quot;, &quot;这个字符串是否匹配规则&quot;)  # 字符串结束位置与匹配规则符合就匹配，否则不匹配\nprint(a)\n[&#39;匹配规则&#39;]\n\n*元字符\n需要字符串里完全符合，匹配规则，就匹配，（规则里的*元字符）前面的一个字符可以是 0 个或多个原本字符\n匹配前一个字符 0 或多次，贪婪匹配前导字符有多少个就匹配多少个很贪婪\n如果规则里只有一个分组，尽量避免用*否则会有可能匹配出空字符串\nimport re\n# 需要字符串里完全符合，匹配规则，就匹配，（规则里的*元字符）前面的一个字符可以是0或多个原本字符\na &#x3D; re.findall(&quot;匹配规则*&quot;, &quot;这个字符串是否匹配规则则则则则&quot;)\nprint(a)\n[&#39;匹配规则则则则则&#39;]\n\n+元字符\n需要字符串里完全符合，匹配规则，就匹配，（规则里的+元字符）前面的一个字符可以是 1 个或多个原本字符\n匹配前一个字符 1 次或无限次，贪婪匹配前导字符有多少个就匹配多少个很贪婪\nimport re\n# 需要字符串里完全符合，匹配规则，就匹配，（规则里的+元字符）前面的一个字符可以是1个或多个原本字符\na &#x3D; re.findall(&quot;匹配+&quot;, &quot;匹配配配配配规则这个字符串是否匹配规则则则则则&quot;)\nprint(a)\n[&#39;匹配配配配配&#39;, &#39;匹配&#39;]\n\n?元字符(防止贪婪匹配)\n需要字符串里完全符合，匹配规则，就匹配，（规则里的?元字符）前面的一个字符可以是 0 个或 1 个原本字符\n匹配一个字符 0 次或 1 次\n还有一个功能是可以防止贪婪匹配，详情见防贪婪匹配\nimport re\n# 需要字符串里完全符合，匹配规则，就匹配，（规则里的?元字符）前面的一个字符可以是0个或1个原本字符\na &#x3D; re.findall(&quot;匹配规则?&quot;, &quot;匹配规这个字符串是否匹配规则则则则则&quot;)\nprint(a)\n[&#39;匹配规&#39;, &#39;匹配规则&#39;]\n\n{}元字符(范围)\n需要字符串里完全符合，匹配规则，就匹配，（规则里的 {} 元字符）前面的一个字符，是自定义字符数，位数的原本字符\n{m}匹配前一个字符 m 次，{m,n}匹配前一个字符 m 至 n 次，若省略 n，则匹配 m 至无限次\n{0,}匹配前一个字符 0 或多次,等同于*元字符{+,}匹配前一个字符 1 次或无限次,等同于+元字符{0,1}匹配前一个字符 0 次或 1 次,等同于?元字符\nimport re\n# &#123;m&#125;匹配前一个字符m次，&#123;m,n&#125;匹配前一个字符m至n次，若省略n，则匹配m至无限次\na &#x3D; re.findall(&quot;匹配规则&#123;3&#125;&quot;, &quot;匹配规这个字符串是否匹配规则则则则则&quot;)\nprint(a)\n[&#39;匹配规则则则&#39;]\n\n[]元字符(字符集)\n需要字符串里完全符合，匹配规则，就匹配，（规则里的 [] 元字符）对应位置是[]里的任意一个字符就匹配\n字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非 abc。所有特殊字符在字符集中都失去其原有的特殊含义。用\\反斜杠转义恢复特殊字符的特殊含义。\nimport re\n# 需要字符串里完全符合，匹配规则，就匹配，（规则里的 [] 元字符）对应位置是[]里的任意一个字符就匹配\na &#x3D; re.findall(&quot;匹配[a,b,c]规则&quot;, &quot;匹配a规则这个字符串是否匹配b规则则则则则&quot;)\nprint(a)\n[&#39;匹配a规则&#39;, &#39;匹配b规则&#39;]\n\n[^]\n非，反取，匹配出除[]里面的字符，元字符如果写到字符集里就是反取\nCopyimport re\na &#x3D; re.findall(&quot;[^a-z]&quot;, &quot;匹配s规则这s个字符串是否s匹配f规则则re则则则&quot;)  # 反取，匹配出除字母外的字符\nprint(a)\nCopy[&#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;这&#39;, &#39;个&#39;, &#39;字&#39;, &#39;符&#39;, &#39;串&#39;, &#39;是&#39;, &#39;否&#39;, &#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;]\n\n反斜杠后边跟普通字符实现特殊功能(预定义字符)\n预定义字符是在字符集和组里都是有用的\n\\d 匹配任何十进制数，它相当于类[0-9]\nimport re\na &#x3D; re.findall(&quot;\\d&quot;, &quot;匹配规则这2个字符串3是否匹配规则5则则则7则&quot;)  # \\d匹配任何十进制数，它相当于类[0-9]\nprint(a)\n[&#39;2&#39;, &#39;3&#39;, &#39;5&#39;, &#39;7&#39;]\n\n\\d+\n匹配一位或者多位数的数字时用\nimport re\na &#x3D; re.findall(&quot;\\d+&quot;, &quot;匹配规则这2个字符串134444是否匹配规则5则则则7则&quot;)  # \\d+如果需要匹配一位或者多位数的数字时用\nprint(a)\n[&#39;2&#39;, &#39;134444&#39;, &#39;5&#39;, &#39;7&#39;]\n\n\\D\n匹配任何非数字字符，它相当于类[^0-9]\nimport re\na &#x3D; re.findall(&quot;\\D&quot;, &quot;匹配规则这2个字符串3是否匹配规则5则则则7则&quot;)  # \\D匹配任何非数字字符，它相当于类[^0-9]\nprint(a)\n[&#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;这&#39;, &#39;个&#39;, &#39;字&#39;, &#39;符&#39;, &#39;串&#39;, &#39;是&#39;, &#39;否&#39;, &#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;]\n\n\\s\n匹配任何空白字符，它相当于类[\\t\\n\\r\\f\\v]\nimport re\n# \\s匹配任何空白字符，它相当于类[\\t\\n\\r\\f\\v]\na &#x3D; re.findall(&quot;\\s&quot;, &quot;匹配规则   这2个字符串3是否匹\\n配规则5则则则7则&quot;)\nprint(a)\n[&#39; &#39;, &#39; &#39;, &#39; &#39;, &#39;\\n&#39;]\n\n\\S\n匹配任何非空白字符，它相当于类[^\\t\\n\\r\\f\\v]\nimport re\n# \\S匹配任何非空白字符，它相当于类[^\\t\\n\\r\\f\\v]\na &#x3D; re.findall(&quot;\\S&quot;, &quot;匹配规则   这2个字符串3是否匹\\n配规则5则则则7则&quot;)\nprint(a)\n[&#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;这&#39;, &#39;2&#39;, &#39;个&#39;, &#39;字&#39;, &#39;符&#39;, &#39;串&#39;, &#39;3&#39;, &#39;是&#39;, &#39;否&#39;, &#39;匹&#39;, &#39;配&#39;, &#39;规&#39;, &#39;则&#39;, &#39;5&#39;, &#39;则&#39;, &#39;则&#39;, &#39;则&#39;, &#39;7&#39;, &#39;则&#39;]\n\n\\w\n匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]\nimport re\n# \\w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]\na &#x3D; re.findall(&#39;\\w&#39;, &quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;&quot;)\nprint(a)\n[&#39;h&#39;, &#39;t&#39;, &#39;t&#39;, &#39;p&#39;, &#39;s&#39;, &#39;w&#39;, &#39;w&#39;, &#39;w&#39;, &#39;c&#39;, &#39;n&#39;, &#39;b&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;, &#39;c&#39;, &#39;o&#39;, &#39;m&#39;]\n\n\\W\n匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]\nimport re\n# \\w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]\na &#x3D; re.findall(&#39;\\W&#39;, &quot;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;&quot;)\nprint(a)\n[&#39;:&#39;, &#39;&#x2F;&#39;, &#39;&#x2F;&#39;, &#39;.&#39;, &#39;.&#39;, &#39;&#x2F;&#39;]\n\n()元字符(分组)\n也就是分组匹配，()里面的为一个组也可以理解成一个整体\n如果()后面跟的是特殊元字符如 (adc)* 那么*控制的前导字符就是()里的整体内容，不再是前导一个字符\nimport re\n# 也就是分组匹配，()里面的为一个组也可以理解成一个整体\na &#x3D; re.search(&quot;(a4)+&quot;, &quot;a4a4a4a4a4dg4g654gb&quot;)  # 匹配一个或多个a4\nb &#x3D; a.group()\nprint(b)\na4a4a4a4a4\nimport re\n# 也就是分组匹配，()里面的为一个组也可以理解成一个整体\n# 匹配 (a) (\\d0-9的数字) (+可以是1个到多个0-9的数字)\na &#x3D; re.search(&quot;a(\\d+)&quot;, &quot;a466666664a4a4a4dg4g654gb&quot;)\nb &#x3D; a.group()\nprint(b)\na466666664\n\n|元字符(或)\n|或，或就是前后其中一个符合就匹配\nimport re\na &#x3D; re.findall(r&quot;你|好&quot;, &quot;a4a4a你4aabc4a4dgg好dg4g654g&quot;)  # |或，或就是前后其中一个符合就匹配\nprint(a)\n[&#39;你&#39;, &#39;好&#39;]\n\n三、re 模块中常用功能函数3.1 正则表达式的两种书写方式1.一种是直接在函数里书写规则，推荐使用\nimport re\na &#x3D; re.findall(&quot;匹配规则&quot;, &quot;这个字符串是否有匹配规则的字符&quot;)\n[&#39;匹配规则&#39;]\n\n2.另一种是先将正则表达式的字符串形式编译为 Pattern 实例，然后使用 Pattern 实例处理文本并获得匹配结果（一个 Match 实例），最后使用 Match 实例获得信息，进行其他的操作。\nimport re\n\n# 将正则表达式编译成Pattern对象\npattern &#x3D; re.compile(r&#39;hello&#39;)\n\n# 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None\nmatch &#x3D; pattern.match(&#39;hello world!&#39;)\n\nif match:\n    # 使用Match获得分组信息\n    print(match.group())\nhello\n\n3.2 re.compile(strPattern[, flag])函数这个方法是 Pattern 类的工厂方法，用于将字符串形式的正则表达式编译为 Pattern 对象。 第二个参数 flag 是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如 re.I | re.M。另外，你也可以在 regex 字符串中指定模式，比如 re.compile(‘pattern’, re.I | re.M)与 re.compile(‘(?im)pattern’)是等价的。\n下表是所有的正则匹配模式：\n\n\n\n修饰符\n描述\n\n\n\nre.I\n使匹配对大小写不敏感\n\n\nre.L\n做本地化识别（locale-aware）匹配\n\n\nre.M\n多行匹配，影响 ^ 和 $\n\n\nre.S\n使 . 匹配包括换行在内的所有字符\n\n\nre.U\n根据 Unicode 字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.\n\n\nre.X\n该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。\n\n\n3.2.1 re.S\n在 Python 的正则表达式中，有一个参数为 re.S。它表示 “.” 的作用扩展到整个字符串，包括“\\n”。看如下代码：\n\nimport re\na &#x3D; &#39;&#39;&#39;asdfhellopass:\n    worldaf\n    &#39;&#39;&#39;\nb &#x3D; re.findall(&#39;hello(.*?)world&#39;, a)\nc &#x3D; re.findall(&#39;hello(.*?)world&#39;, a, re.S)\nprint(&#39;b is &#39;, b)\nprint(&#39;c is &#39;, c)\nb is  []\nc is  [&#39;pass:\\n    &#39;]\n\n正则表达式中，“.”的作用是匹配除“\\n”以外的任何字符，也就是说，它是在一行中进行匹配。这里的“行”是以“\\n”进行区分的。a 字符串有每行的末尾有一个“\\n”，不过它不可见。\n如果不使用 re.S 参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始，不会跨行。而使用 re.S 参数以后，正则表达式会将这个字符串作为一个整体，将“\\n”当做一个普通的字符加入到这个字符串中，在整体中进行匹配。\n3.2.2 re.I\n不区分大小写\n\nres &#x3D; re.findall(r&quot;A&quot;, &quot;abc&quot;, re.I)\nprint(res)\n[&#39;a&#39;]\n\n3.2.3 re.M\n将所有行的尾字母输出（python3+已经无效）\n\ns &#x3D; &#39;12 34&#x2F;n56 78&#x2F;n90&#39;\n\nre.findall(r&#39;^&#x2F;d+&#39;, s, re.M)  # 匹配位于行首的数字  # [&#39;12&#39;, &#39;56&#39;, &#39;90&#39;]\nre.findall(r&#39;&#x2F;A&#x2F;d+&#39;, s, re.M)  # 匹配位于字符串开头的数字  # [&#39;12&#39;]\nre.findall(r&#39;&#x2F;d+$&#39;, s, re.M)  # 匹配位于行尾的数字  # [&#39;34&#39;, &#39;78&#39;, &#39;90&#39;]\nre.findall(r&#39;&#x2F;d+&#x2F;Z&#39;, s, re.M)  # 匹配位于字符串尾的数字  # [&#39;90&#39;]\n\n3.2.4 re.sub# 要求结果：[&#39;12&#39;, &#39;23&#39;, &#39;34&#39;]\nl &#x3D; [&#39;1 2 &#39;, &#39;2   3&#39;, &#39;  3 4&#39;]\nimport re\nprint(eval(re.sub(r&#39;\\s*&#39;, &#39;&#39;, str(l))))\n[&#39;12&#39;, &#39;23&#39;, &#39;34&#39;]\n\n3.3 re.match(pattern, string[, flags])函数(常用)match，从头匹配一个符合规则的字符串，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回 Nonematch(pattern, string, flags&#x3D;0)\n\npattern： 正则模型\nstring ： 要匹配的字符串\nfalgs ： 匹配模式\n\n注意：match()函数 与 search()函数基本是一样的功能，不一样的就是 match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串\nimport re\n# 无分组\norigin &#x3D; &quot;hello egon bcd egon lge egon acd 19&quot;\nr &#x3D; re.match(&quot;h\\w+&quot;, origin)  # match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None\nprint(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来\nprint(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\nprint(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果\nhello\n()\n&#123;&#125;\n# 有分组\n# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）\nr &#x3D; re.match(&quot;h(\\w+)&quot;, origin)  # match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None\nprint(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来\nprint(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\nprint(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果\nhello\n(&#39;ello&#39;,)\n&#123;&#125;\n# 有两个分组定义了key\n# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）\n# ?P&lt;&gt;定义组里匹配内容的key(键)，&lt;&gt;里面写key名称，值就是匹配到的内容\nr &#x3D; re.match(&quot;(?P&lt;n1&gt;h)(?P&lt;n2&gt;\\w+)&quot;, origin)\nprint(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来\nprint(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\nprint(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果\nhello\n(&#39;h&#39;, &#39;ello&#39;)\n&#123;&#39;n1&#39;: &#39;h&#39;, &#39;n2&#39;: &#39;ello&#39;&#125;\n\n3.4 分组函数?P&lt;n1&gt; # ?P&lt;&gt;定义组里匹配内容的 key(键)，&lt;&gt;里面写 key 名称，值就是匹配到的内容（只对正则函数返回对象时有用）\n取出匹配对象方法\n只对正则函数返回对象的有用\n\ngroup() # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如 2\ngroups() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\ngroupdict() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了 key 的组结果\n\n3.5 re.search(pattern, string[, flags])函数search,浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回 None\nsearch(pattern, string, flags&#x3D;0)\n\npattern： 正则模型\nstring ： 要匹配的字符串\nfalgs ： 匹配模式\n\n注意：match()函数 与 search()函数基本是一样的功能，不一样的就是 match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串\nimport re\n# 无分组\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\n# search浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None\nr &#x3D; re.search(&quot;a\\w+&quot;, origin)\nprint(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来\nprint(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\nprint(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果\nalex\n()\n&#123;&#125;\n# 有分组\n# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）\nr &#x3D; re.search(&quot;a(\\w+).*(\\d)&quot;, origin)\nprint(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来\nprint(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\nprint(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果\nalex bcd alex lge alex acd 19\n(&#39;lex&#39;, &#39;9&#39;)\n&#123;&#125;\n# 有两个分组定义了key\n# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）\n# ?P&lt;&gt;定义组里匹配内容的key(键)，&lt;&gt;里面写key名称，值就是匹配到的内容\nr &#x3D; re.search(&quot;a(?P&lt;n1&gt;\\w+).*(?P&lt;n2&gt;\\d)&quot;, origin)\nprint(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来\nprint(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\nprint(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果\nalex bcd alex lge alex acd 19\n(&#39;lex&#39;, &#39;9&#39;)\n&#123;&#39;n1&#39;: &#39;lex&#39;, &#39;n2&#39;: &#39;9&#39;&#125;\n\n3.6 re.findall(pattern, string[, flags])函数(常用)findall(pattern, string, flags&#x3D;0)\n\npattern： 正则模型\nstring ： 要匹配的字符串\nfalgs ： 匹配模式\n\n浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中，未匹配成功返回空列表\n注意：一旦匹配成，再次匹配，是从前一次匹配成功的，后面一位开始的，也可以理解为匹配成功的字符串，不在参与下次匹配\nimport re\n# 无分组\nr &#x3D; re.findall(&quot;\\d+\\w\\d+&quot;, &quot;a2b3c4d5&quot;)  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中\nprint(r)  # 注意：匹配成功的字符串，不在参与下次匹配,所以3c4也符合规则但是没匹配到\n[&#39;2b3&#39;, &#39;4d5&#39;]\n\n注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表\nimport re\n# 无分组\nr &#x3D; re.findall(&quot;&quot;, &quot;a2b3c4d5&quot;)  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中\nprint(r)  # 注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表\n[&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]\n\n注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是就表示组里的内容可以是 0 个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里 0 内容（即是空白）所以尽量避免用否则会有可能匹配出空字符串\n注意：正则只拿组里最后一位，如果规则里只有一个组，匹配到的字符串里在拿组内容是，拿的是匹配到的内容最后一位\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\nr &#x3D; re.findall(&quot;(a)*&quot;, origin)\nprint(r)\n[&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]\n\n无分组：匹配所有合规则的字符串，匹配到的字符串放到一个列表中\nimport re\n# 无分组\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\nr &#x3D; re.findall(&quot;a\\w+&quot;, origin)  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中\nprint(r)\n[&#39;alex&#39;, &#39;alex&#39;, &#39;alex&#39;, &#39;acd&#39;]\n\n有分组：只将匹配到的字符串里，组的部分放到列表里返回，相当于 groups()方法\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\nr &#x3D; re.findall(&quot;a(\\w+)&quot;, origin)  # 有分组：只将匹配到的字符串里，组的部分放到列表里返回\nprint(r)\n[&#39;lex&#39;, &#39;lex&#39;, &#39;lex&#39;, &#39;cd&#39;]\n\n多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返\n相当于在 group()结果里再将组的部分，分别，拿出来放入一个元组，最后将所有元组放入一个列表返回\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\n# 多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返回\nr &#x3D; re.findall(&quot;(a)(\\w+)&quot;, origin)\nprint(r)\n[(&#39;a&#39;, &#39;lex&#39;), (&#39;a&#39;, &#39;lex&#39;), (&#39;a&#39;, &#39;lex&#39;), (&#39;a&#39;, &#39;cd&#39;)]\n\n分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\n# 分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回\nr &#x3D; re.findall(&quot;(a)(\\w+(e))&quot;, origin)\nprint(r)\n[(&#39;a&#39;, &#39;le&#39;, &#39;e&#39;), (&#39;a&#39;, &#39;le&#39;, &#39;e&#39;), (&#39;a&#39;, &#39;le&#39;, &#39;e&#39;)]\n\n?:在有分组的情况下 findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如 findall()\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\n# ?:在有分组的情况下，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()\nb &#x3D; re.findall(&quot;a(?:\\w+)&quot;, origin)\nprint(b)\n[&#39;alex&#39;, &#39;alex&#39;, &#39;alex&#39;, &#39;acd&#39;]\n\n3.7 re.split(pattern, string[, maxsplit])函数根据正则匹配分割字符串，返回分割后的一个列表\nsplit(pattern, string, maxsplit&#x3D;0, flags&#x3D;0)\n\npattern： 正则模型\nstring ： 要匹配的字符串\nmaxsplit：指定分割个数\nflags ： 匹配模式\n\n按照一个字符将全部字符串进行分割\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\nr &#x3D; re.split(&quot;a&quot;, origin)  # 根据正则匹配分割字符串\nprint(r)\n[&#39;hello &#39;, &#39;lex bcd &#39;, &#39;lex lge &#39;, &#39;lex &#39;, &#39;cd 19&#39;]\n\n将匹配到的字符串作为分割标准进行分割\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex 2acd 19&quot;\nr &#x3D; re.split(&quot;a\\w+&quot;, origin)  # 根据正则匹配分割字符串\nprint(r)\n[&#39;hello &#39;, &#39; bcd &#39;, &#39; lge &#39;, &#39; 2&#39;, &#39; 19&#39;]\n\n3.8 re.sub(pattern, repl, string[, count])函数替换匹配成功的指定位置字符串\nsub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)\n\npattern： 正则模型\nrepl ： 要替换的字符串\nstring ： 要匹配的字符串\ncount ： 指定匹配个数\nflags ： 匹配模式\n\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\nr &#x3D; re.sub(&quot;a&quot;, &quot;替换&quot;, origin)  # 替换匹配成功的指定位置字符串\nprint(r)\nhello 替换lex bcd 替换lex lge 替换lex 替换cd 19\n\n3.9 re.subn(pattern, repl, string,[, count][, flags])函数替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受\nsubn(pattern, repl, string, count&#x3D;0, flags&#x3D;0)\n\npattern： 正则模型\nrepl ： 要替换的字符串\nstring ： 要匹配的字符串\ncount ： 指定匹配个数\nflags ： 匹配模式\n\nimport re\norigin &#x3D; &quot;hello alex bcd alex lge alex acd 19&quot;\na, b &#x3D; re.subn(&quot;a&quot;, &quot;替换&quot;, origin)  # 替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受\nprint(a)\nprint(b)\nhello 替换lex bcd 替换lex lge 替换lex 替换cd 19\n4\n\n四、注意事项\nr 原生字符：让在 python 里有特殊意义的字符如\\b，转换成原生字符（就是去除它在 python 的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符 r\n正则表达式，返回类型为表达式对象的，如：&lt;_sre.SRE_Match object; span&#x3D;(6, 7), match&#x3D;’a’&gt;，返回对象时，需要用正则方法取字符串，方法有：\ngroup() # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如 2\ngroups() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果\ngroupdict() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了 key 的组结果\n\n\n匹配到的字符串里出现空字符：注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是就表示组里的内容可以是 0 个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里 0 内容（即是空白）所以尽量避免用否则会有可能匹配出空字符串\n()分组：注意：分组的意义，就是在匹配成功的字符串中，再提取()里的内容，也就是组里面的字符串\n?:在有分组的情况下 findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如 findall()\n\n五、计算器(经典)基于递归和正则将下面的字符串翻译成计算器表达式，并且获取最终结果：expression=&#39;-1-2*((60+2*(-3-40.0+42425/5)*(9-2*5/3+357/553/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))+56+(56-45)&#39;\n如果代码正确，计算结果为：-553071849.7670887\n提示：content=re.search(&#39;\\(([\\-\\+\\*\\/]*\\d+\\.?\\d*)+\\)&#39;,expression).group() #(-3-40.0/5)\n5.1 复杂版本#!&#x2F;usr&#x2F;bin&#x2F;env python\n# -*- coding:utf-8 -*-\n&quot;&quot;&quot;\n该计算器思路：\n    1、递归寻找表达式中只含有 数字和运算符的表达式，并计算结果\n    2、由于整数计算会忽略小数，所有的数字都认为是浮点型操作，以此来保留小数\n使用技术：\n    1、正则表达式\n    2、递归\n&quot;&quot;&quot;\n\nimport re\n\n\ndef compute_mul_div(arg):\n    &quot;&quot;&quot; 操作乘除\n    :param expression:表达式\n    :return:计算结果\n    &quot;&quot;&quot;\n\n    val &#x3D; arg[0]\n    mch &#x3D; re.search(&#39;\\d+\\.*\\d*[\\*\\&#x2F;]+[\\+\\-]?\\d+\\.*\\d*&#39;, val)\n    if not mch:\n        return\n    content &#x3D; re.search(&#39;\\d+\\.*\\d*[\\*\\&#x2F;]+[\\+\\-]?\\d+\\.*\\d*&#39;, val).group()\n\n    if len(content.split(&#39;*&#39;)) &gt; 1:\n        n1, n2 &#x3D; content.split(&#39;*&#39;)\n        value &#x3D; float(n1) * float(n2)\n    else:\n        n1, n2 &#x3D; content.split(&#39;&#x2F;&#39;)\n        value &#x3D; float(n1) &#x2F; float(n2)\n\n    before, after &#x3D; re.split(&#39;\\d+\\.*\\d*[\\*\\&#x2F;]+[\\+\\-]?\\d+\\.*\\d*&#39;, val, 1)\n    new_str &#x3D; &quot;%s%s%s&quot; % (before, value, after)\n    arg[0] &#x3D; new_str\n    compute_mul_div(arg)\n\n\ndef compute_add_sub(arg):\n    &quot;&quot;&quot; 操作加减\n    :param expression:表达式\n    :return:计算结果\n    &quot;&quot;&quot;\n    while True:\n        if arg[0].__contains__(&#39;+-&#39;) or arg[0].__contains__(&quot;++&quot;) or arg[\n                0].__contains__(&#39;-+&#39;) or arg[0].__contains__(&quot;--&quot;):\n            arg[0] &#x3D; arg[0].replace(&#39;+-&#39;, &#39;-&#39;)\n            arg[0] &#x3D; arg[0].replace(&#39;++&#39;, &#39;+&#39;)\n            arg[0] &#x3D; arg[0].replace(&#39;-+&#39;, &#39;-&#39;)\n            arg[0] &#x3D; arg[0].replace(&#39;--&#39;, &#39;+&#39;)\n        else:\n            break\n\n    if arg[0].startswith(&#39;-&#39;):\n        arg[1] +&#x3D; 1\n        arg[0] &#x3D; arg[0].replace(&#39;-&#39;, &#39;&amp;&#39;)\n        arg[0] &#x3D; arg[0].replace(&#39;+&#39;, &#39;-&#39;)\n        arg[0] &#x3D; arg[0].replace(&#39;&amp;&#39;, &#39;+&#39;)\n        arg[0] &#x3D; arg[0][1:]\n    val &#x3D; arg[0]\n    mch &#x3D; re.search(&#39;\\d+\\.*\\d*[\\+\\-]&#123;1&#125;\\d+\\.*\\d*&#39;, val)\n    if not mch:\n        return\n    content &#x3D; re.search(&#39;\\d+\\.*\\d*[\\+\\-]&#123;1&#125;\\d+\\.*\\d*&#39;, val).group()\n    if len(content.split(&#39;+&#39;)) &gt; 1:\n        n1, n2 &#x3D; content.split(&#39;+&#39;)\n        value &#x3D; float(n1) + float(n2)\n    else:\n        n1, n2 &#x3D; content.split(&#39;-&#39;)\n        value &#x3D; float(n1) - float(n2)\n\n    before, after &#x3D; re.split(&#39;\\d+\\.*\\d*[\\+\\-]&#123;1&#125;\\d+\\.*\\d*&#39;, val, 1)\n    new_str &#x3D; &quot;%s%s%s&quot; % (before, value, after)\n    arg[0] &#x3D; new_str\n    compute_add_sub(arg)\n\n\ndef compute(expression):\n    &quot;&quot;&quot; 操作加减乘除\n    :param expression:表达式\n    :return:计算结果\n    &quot;&quot;&quot;\n    inp &#x3D; [expression, 0]\n\n    # 处理表达式中的乘除\n    compute_mul_div(inp)\n\n    # 处理\n    compute_add_sub(inp)\n    if divmod(inp[1], 2)[1] &#x3D;&#x3D; 1:\n        result &#x3D; float(inp[0])\n        result &#x3D; result * -1\n    else:\n        result &#x3D; float(inp[0])\n    return result\n\n\ndef exec_bracket(expression):\n    &quot;&quot;&quot; 递归处理括号，并计算\n    :param expression: 表达式\n    :return:最终计算结果\n    &quot;&quot;&quot;\n    # 如果表达式中已经没有括号，则直接调用负责计算的函数，将表达式结果返回，如：2*1-82+444\n    if not re.search(&#39;\\(([\\+\\-\\*\\&#x2F;]*\\d+\\.*\\d*)&#123;2,&#125;\\)&#39;, expression):\n        final &#x3D; compute(expression)\n        return final\n    # 获取 第一个 只含有 数字&#x2F;小数 和 操作符 的括号\n    # 如：\n    #    [&#39;1-2*((60-30+(-40.0&#x2F;5)*(9-2*5&#x2F;3+7&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))&#39;]\n    #    找出：(-40.0&#x2F;5)\n    content &#x3D; re.search(&#39;\\(([\\+\\-\\*\\&#x2F;]*\\d+\\.*\\d*)&#123;2,&#125;\\)&#39;, expression).group()\n\n    # 分割表达式，即：\n    # 将[&#39;1-2*((60-30+(-40.0&#x2F;5)*(9-2*5&#x2F;3+7&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))&#39;]\n    # 分割更三部分：[&#39;1-2*((60-30+(    (-40.0&#x2F;5)      *(9-2*5&#x2F;3+7&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))&#39;]\n    before, nothing, after &#x3D; re.split(&#39;\\(([\\+\\-\\*\\&#x2F;]*\\d+\\.*\\d*)&#123;2,&#125;\\)&#39;,\n                                      expression, 1)\n\n    print(&#39;before：&#39;, expression)\n    content &#x3D; content[1:len(content) - 1]\n\n    # 计算，提取的表示 (-40.0&#x2F;5)，并活的结果，即：-40.0&#x2F;5&#x3D;-8.0\n    ret &#x3D; compute(content)\n\n    print(&#39;%s&#x3D;%s&#39; % (content, ret))\n\n    # 将执行结果拼接，[&#39;1-2*((60-30+(      -8.0     *(9-2*5&#x2F;3+7&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))&#39;]\n    expression &#x3D; &quot;%s%s%s&quot; % (before, ret, after)\n    print(&#39;after：&#39;, expression)\n    print(&quot;&#x3D;&quot; * 10, &#39;上一次计算结束&#39;, &quot;&#x3D;&quot; * 10)\n\n    # 循环继续下次括号处理操作，本次携带者的是已被处理后的表达式，即：\n    # [&#39;1-2*((60-30+   -8.0  *(9-2*5&#x2F;3+7&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))&#39;]\n\n    # 如此周而复始的操作，直到表达式中不再含有括号\n    return exec_bracket(expression)\n\n\n# 使用 __name__ 的目的：\n# 只有执行 python index.py 时，以下代码才执行\n# 如果其他人导入该模块，以下代码不执行\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    print(\n        &#39;*&#39; * 20, &quot;请计算表达式：&quot;,\n        &quot;1 - 2 * ( (60-30 +(-40.0&#x2F;5) * (9-2*5&#x2F;3 + 7 &#x2F;3*99&#x2F;4*2998 +10 * 568&#x2F;14 )) - (-4*3)&#x2F; (16-3*2) )&quot;,\n        &#39;*&#39; * 20)\n    #     inpp &#x3D; &#39;1 - 2 * ( (60-30 +(-40.0&#x2F;5) * (9-2*5&#x2F;3 + 7 &#x2F;3*99&#x2F;4*2998 +10 * 568&#x2F;14 )) - (-4*3)&#x2F; (16-3*2) ) &#39;\n    inpp &#x3D; &#39;-1-2*((60+2*(-3-40.0+42425&#x2F;5)*(9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))+56+(56-45)&#39;\n    # inpp &#x3D; &quot;1-2*-30&#x2F;-12*(-20+200*-3&#x2F;-200*-300-100)&quot;\n    # inpp &#x3D; &quot;1-5*980.0&quot;\n    inpp &#x3D; re.sub(&#39;\\s*&#39;, &#39;&#39;, inpp)\n    # 表达式保存在列表中\n    result &#x3D; exec_bracket(inpp)\n    print(result)\n******************** 请计算表达式： 1 - 2 * ( (60-30 +(-40.0&#x2F;5) * (9-2*5&#x2F;3 + 7 &#x2F;3*99&#x2F;4*2998 +10 * 568&#x2F;14 )) - (-4*3)&#x2F; (16-3*2) ) ********************\nbefore： -1-2*((60+2*(-3-40.0+42425&#x2F;5)*(9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))+56+(56-45)\n-3-40.0+42425&#x2F;5&#x3D;8442.0\nafter： -1-2*((60+2*8442.0*(9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))+56+(56-45)\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 上一次计算结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nbefore： -1-2*((60+2*8442.0*(9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))+56+(56-45)\n9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14&#x3D;16378.577154912598\nafter： -1-2*((60+2*8442.0*16378.577154912598)-(-4*3)&#x2F;(16-3*2))+56+(56-45)\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 上一次计算结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nbefore： -1-2*((60+2*8442.0*16378.577154912598)-(-4*3)&#x2F;(16-3*2))+56+(56-45)\n60+2*8442.0*16378.577154912598&#x3D;276535956.68354434\nafter： -1-2*(276535956.68354434-(-4*3)&#x2F;(16-3*2))+56+(56-45)\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 上一次计算结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nbefore： -1-2*(276535956.68354434-(-4*3)&#x2F;(16-3*2))+56+(56-45)\n-4*3&#x3D;-12.0\nafter： -1-2*(276535956.68354434--12.0&#x2F;(16-3*2))+56+(56-45)\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 上一次计算结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nbefore： -1-2*(276535956.68354434--12.0&#x2F;(16-3*2))+56+(56-45)\n16-3*2&#x3D;10.0\nafter： -1-2*(276535956.68354434--12.0&#x2F;10.0)+56+(56-45)\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 上一次计算结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nbefore： -1-2*(276535956.68354434--12.0&#x2F;10.0)+56+(56-45)\n276535956.68354434--12.0&#x2F;10.0&#x3D;276535957.8835443\nafter： -1-2*276535957.8835443+56+(56-45)\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 上一次计算结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nbefore： -1-2*276535957.8835443+56+(56-45)\n56-45&#x3D;11.0\nafter： -1-2*276535957.8835443+56+11.0\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 上一次计算结束 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n-553071849.7670887\n\n5.2 简单易懂版Copyimport re\n\nexpression &#x3D; &#39;-1-2*((60+2*(-3-40.0+42425&#x2F;5)*(9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))+56+(56-45)&#39;\nquestion &#x3D; eval(expression)\nprint(question)\n\n\ndef arithmetic(expression&#x3D;&#39;1+1&#39;):\n    #     content &#x3D; re.search(&#39;\\(([\\-\\+\\*\\&#x2F;]*\\d+\\.?\\d*)+\\)&#39;, expression)  # (-3-40.0&#x2F;5)\n    content &#x3D; re.search(&#39;\\(([-+*&#x2F;]*\\d+\\.?\\d*)+\\)&#39;, expression)  # (-3-40.0&#x2F;5)\n    if content:\n        content &#x3D; content.group()\n        content &#x3D; content[1:-1]\n        print(&#39;content:&#39;, content)\n        replace_content &#x3D; next_arithmetic(content)\n        expression &#x3D; re.sub(&#39;\\(([-+*&#x2F;]*\\d+\\.?\\d*)+\\)&#39;,\n                            replace_content,\n                            expression,\n                            count&#x3D;1)\n        print(&#39;next_expression:&#39;, expression)\n    else:\n        answer &#x3D; next_arithmetic(expression)\n        return answer\n    return arithmetic(expression)\n\n\ndef next_arithmetic(content):\n    while True:\n        next_content_mul_div &#x3D; re.search(&#39;\\d+\\.?\\d*[*&#x2F;][-+]?\\d+\\.?\\d*&#39;,\n                                         content)  # 找出带有*&#x2F;的式子\n        if next_content_mul_div:  # 如果content含有带有*&#x2F;的式子\n            next_content_mul_div &#x3D; next_content_mul_div.group()\n            print(&#39;next_content_mul_div:&#39;, next_content_mul_div)\n            mul_div_content &#x3D; mul_div(next_content_mul_div)  # 计算出带有*&#x2F;的式子\n            print(&#39;mul_div_content:&#39;, mul_div_content)\n            content &#x3D; re.sub(&#39;\\d+\\.?\\d*[*&#x2F;][-+]?\\d+\\.?\\d*&#39;,\n                             str(mul_div_content),\n                             content,\n                             count&#x3D;1)  # 把带有*&#x2F;的式子计算出来后替换掉\n            print(&#39;content:&#39;, content)\n            continue\n        next_content_add_sub &#x3D; re.search(&#39;-?\\d+\\.?\\d*[-+][-+]?\\d+\\.?\\d*&#39;,\n                                         content)  # 找出带有-+的式子\n        if next_content_add_sub:  # 如果content含有带有+-的式子\n            next_content_add_sub &#x3D; next_content_add_sub.group()\n            print(&#39;next_content_add_sub:&#39;, next_content_add_sub)\n            add_sub_content &#x3D; add_sub(next_content_add_sub)  # 计算出带有-+的式子\n            print(&#39;add_sub_content:&#39;, add_sub_content)\n            add_sub_content &#x3D; str(add_sub_content)\n            content &#x3D; re.sub(&#39;-?\\d+\\.?\\d*[-+]-?\\d+\\.?\\d*&#39;,\n                             str(add_sub_content),\n                             content,\n                             count&#x3D;1)  # 把带有-+的式子计算出来后替换掉\n            print(&#39;content:&#39;, content)\n            continue\n        else:\n            break\n    return content\n\n\ndef add_sub(content):\n    if &#39;+&#39; in content:\n        content &#x3D; content.split(&#39;+&#39;)\n        print(content)\n        content &#x3D; float(content[0]) + float(content[1])\n        return content\n    elif &#39;-&#39; in content:\n        content &#x3D; content.split(&#39;-&#39;)\n        # 减法情况有多种\n        if content[0] &#x3D;&#x3D; &#39;-&#39; and content[2] &#x3D;&#x3D; &#39;-&#39;:\n            # content &#x3D; content.split(&#39;-&#39;)\n            print(content)\n            content &#x3D; -float(content[1]) - float(content[-1])\n            return content\n        if content[0] &#x3D;&#x3D; &#39;-&#39;:\n            # content &#x3D; content.split(&#39;-&#39;)\n            print(content)\n            content &#x3D; -float(content[1]) - float(content[-1])\n            return content\n        if content[1] &#x3D;&#x3D; &#39;-&#39; and content[2] &#x3D;&#x3D; &#39;-&#39;:\n            # content &#x3D; content.split(&#39;-&#39;)\n            print(content)\n            content &#x3D; -float(content[0]) + float(content[-1])\n            return content\n        if content[1] &#x3D;&#x3D; &#39;&#39;:\n            # content &#x3D; content.split(&#39;-&#39;)\n            print(content)\n            content &#x3D; float(content[0]) - float(content[2])\n            return content\n        if content[0] &#x3D;&#x3D; &#39;&#39; and content[2] !&#x3D; &#39;&#39;:\n            print(content)\n            content &#x3D; -float(content[1]) - float(content[2])\n            return content\n        if content[0] &#x3D;&#x3D; &#39;&#39; and content[2] &#x3D;&#x3D; &#39;&#39;:\n            print(content)\n            content &#x3D; -float(content[1]) + float(content[3])\n            return content\n        else:\n            # content &#x3D; content.split(&#39;-&#39;)\n            print(content)\n            content &#x3D; float(content[0]) - float(content[1])\n            return content\n\n\ndef mul_div(content):\n    if &#39;*&#39; in content:\n        content &#x3D; content.split(&#39;*&#39;)\n        print(content)\n        content &#x3D; float(content[0]) * float(content[1])\n        return content\n    elif &#39;&#x2F;&#39; in content:\n        content &#x3D; content.split(&#39;&#x2F;&#39;)\n        print(content)\n        content &#x3D; float(content[0]) &#x2F; float(content[1])\n        return content\n\n\n# expression &#x3D; &#39;1-2*((60+2*(-3-40.0&#x2F;5)*(9-2*5&#x2F;3+7&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))&#39;\nexpression &#x3D; &#39;-1-2*((60+2*(-3-40.0+42425&#x2F;5)*(9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))+56+(56-45)&#39;\nanswer &#x3D; arithmetic(expression)\nprint(answer)\nCopy-553071849.7670887\ncontent: -3-40.0+42425&#x2F;5\nnext_content_mul_div: 42425&#x2F;5\n[&#39;42425&#39;, &#39;5&#39;]\nmul_div_content: 8485.0\ncontent: -3-40.0+8485.0\nnext_content_add_sub: -3-40.0\n[&#39;&#39;, &#39;3&#39;, &#39;40.0&#39;]\nadd_sub_content: -43.0\ncontent: -43.0+8485.0\nnext_content_add_sub: -43.0+8485.0\n[&#39;-43.0&#39;, &#39;8485.0&#39;]\nadd_sub_content: 8442.0\ncontent: 8442.0\nnext_expression: -1-2*((60+2*8442.0*(9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14))-(-4*3)&#x2F;(16-3*2))+56+(56-45)\ncontent: 9-2*5&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14\nnext_content_mul_div: 2*5\n[&#39;2&#39;, &#39;5&#39;]\nmul_div_content: 10.0\ncontent: 9-10.0&#x2F;3+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14\nnext_content_mul_div: 10.0&#x2F;3\n[&#39;10.0&#39;, &#39;3&#39;]\nmul_div_content: 3.3333333333333335\ncontent: 9-3.3333333333333335+357&#x2F;553&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14\nnext_content_mul_div: 357&#x2F;553\n[&#39;357&#39;, &#39;553&#39;]\nmul_div_content: 0.6455696202531646\ncontent: 9-3.3333333333333335+0.6455696202531646&#x2F;3*99&#x2F;4*2998+10*568&#x2F;14\nnext_content_mul_div: 0.6455696202531646&#x2F;3\n[&#39;0.6455696202531646&#39;, &#39;3&#39;]\nmul_div_content: 0.21518987341772153\ncontent: 9-3.3333333333333335+0.21518987341772153*99&#x2F;4*2998+10*568&#x2F;14\nnext_content_mul_div: 0.21518987341772153*99\n[&#39;0.21518987341772153&#39;, &#39;99&#39;]\nmul_div_content: 21.303797468354432\ncontent: 9-3.3333333333333335+21.303797468354432&#x2F;4*2998+10*568&#x2F;14\nnext_content_mul_div: 21.303797468354432&#x2F;4\n[&#39;21.303797468354432&#39;, &#39;4&#39;]\nmul_div_content: 5.325949367088608\ncontent: 9-3.3333333333333335+5.325949367088608*2998+10*568&#x2F;14\nnext_content_mul_div: 5.325949367088608*2998\n[&#39;5.325949367088608&#39;, &#39;2998&#39;]\nmul_div_content: 15967.196202531646\ncontent: 9-3.3333333333333335+15967.196202531646+10*568&#x2F;14\nnext_content_mul_div: 10*568\n[&#39;10&#39;, &#39;568&#39;]\nmul_div_content: 5680.0\ncontent: 9-3.3333333333333335+15967.196202531646+5680.0&#x2F;14\nnext_content_mul_div: 5680.0&#x2F;14\n[&#39;5680.0&#39;, &#39;14&#39;]\nmul_div_content: 405.7142857142857\ncontent: 9-3.3333333333333335+15967.196202531646+405.7142857142857\nnext_content_add_sub: 9-3.3333333333333335\n[&#39;9&#39;, &#39;3.3333333333333335&#39;]\nadd_sub_content: 5.666666666666666\ncontent: 5.666666666666666+15967.196202531646+405.7142857142857\nnext_content_add_sub: 5.666666666666666+15967.196202531646\n[&#39;5.666666666666666&#39;, &#39;15967.196202531646&#39;]\nadd_sub_content: 15972.862869198312\ncontent: 15972.862869198312+405.7142857142857\nnext_content_add_sub: 15972.862869198312+405.7142857142857\n[&#39;15972.862869198312&#39;, &#39;405.7142857142857&#39;]\nadd_sub_content: 16378.577154912598\ncontent: 16378.577154912598\nnext_expression: -1-2*((60+2*8442.0*16378.577154912598)-(-4*3)&#x2F;(16-3*2))+56+(56-45)\ncontent: 60+2*8442.0*16378.577154912598\nnext_content_mul_div: 2*8442.0\n[&#39;2&#39;, &#39;8442.0&#39;]\nmul_div_content: 16884.0\ncontent: 60+16884.0*16378.577154912598\nnext_content_mul_div: 16884.0*16378.577154912598\n[&#39;16884.0&#39;, &#39;16378.577154912598&#39;]\nmul_div_content: 276535896.68354434\ncontent: 60+276535896.68354434\nnext_content_add_sub: 60+276535896.68354434\n[&#39;60&#39;, &#39;276535896.68354434&#39;]\nadd_sub_content: 276535956.68354434\ncontent: 276535956.68354434\nnext_expression: -1-2*(276535956.68354434-(-4*3)&#x2F;(16-3*2))+56+(56-45)\ncontent: -4*3\nnext_content_mul_div: 4*3\n[&#39;4&#39;, &#39;3&#39;]\nmul_div_content: 12.0\ncontent: -12.0\nnext_expression: -1-2*(276535956.68354434--12.0&#x2F;(16-3*2))+56+(56-45)\ncontent: 16-3*2\nnext_content_mul_div: 3*2\n[&#39;3&#39;, &#39;2&#39;]\nmul_div_content: 6.0\ncontent: 16-6.0\nnext_content_add_sub: 16-6.0\n[&#39;16&#39;, &#39;6.0&#39;]\nadd_sub_content: 10.0\ncontent: 10.0\nnext_expression: -1-2*(276535956.68354434--12.0&#x2F;10.0)+56+(56-45)\ncontent: 276535956.68354434--12.0&#x2F;10.0\nnext_content_mul_div: 12.0&#x2F;10.0\n[&#39;12.0&#39;, &#39;10.0&#39;]\nmul_div_content: 1.2\ncontent: 276535956.68354434--1.2\nnext_content_add_sub: 276535956.68354434--1.2\n[&#39;276535956.68354434&#39;, &#39;&#39;, &#39;1.2&#39;]\nadd_sub_content: 276535955.48354435\ncontent: 276535955.48354435\nnext_expression: -1-2*276535955.48354435+56+(56-45)\ncontent: 56-45\nnext_content_add_sub: 56-45\n[&#39;56&#39;, &#39;45&#39;]\nadd_sub_content: 11.0\ncontent: 11.0\nnext_expression: -1-2*276535955.48354435+56+11.0\nnext_content_mul_div: 2*276535955.48354435\n[&#39;2&#39;, &#39;276535955.48354435&#39;]\nmul_div_content: 553071910.9670887\ncontent: -1-553071910.9670887+56+11.0\nnext_content_add_sub: -1-553071910.9670887\n[&#39;&#39;, &#39;1&#39;, &#39;553071910.9670887&#39;]\nadd_sub_content: -553071911.9670887\ncontent: -553071911.9670887+56+11.0\nnext_content_add_sub: -553071911.9670887+56\n[&#39;-553071911.9670887&#39;, &#39;56&#39;]\nadd_sub_content: -553071855.9670887\ncontent: -553071855.9670887+11.0\nnext_content_add_sub: -553071855.9670887+11.0\n[&#39;-553071855.9670887&#39;, &#39;11.0&#39;]\nadd_sub_content: -553071844.9670887\ncontent: -553071844.9670887\n-553071844.9670887\n", "slug": "python学习之re模块", "date": "2023-07-27 00:32:00", "categories_index": "Python", "tags_index": "持久化", "author_index": "倪传方"}, {"id": "2e5004b8a8ff49317aa7f3e9b71f74cf", "title": "可重入锁ReentrantLock高级特性", "content": "ReentrantLock提供了Synchronized不具备的三个高级特性\n公平锁\n\n&#x2F;**\n * Creates an instance of &#123;@code ReentrantLock&#125;.\n * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.\n *&#x2F;\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync();\n&#125;\n\n\n等待可中断\n\n&#x2F;**\n * 尝试锁定\n *\n * @param timeout 超时时间\n * @param unit    单位\n * @return boolean 尝试获取锁的结果\n * @throws InterruptedException 中断异常\n *&#x2F;\npublic boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n&#125;\n\n\n\n\n\n\n\n提示\n条件通知,一把锁可以生成多个条件,每个条件可以对应一个线程分组,可以通过 condition 对象来进行分组等待和唤醒,解决了synchronized关键字只能notifyAll()的问题\n\npublic Condition newCondition() &#123;\n    return sync.newCondition();\n&#125;\n\n\n\n\n\n\n\n\n注意\nReentrantLock条件通知使用注意点\n\n\n每个 condition 可以绑定若干个线程,如果需要多个 condition 请先对线程进行分组;\n使用await()和signal()或者signalAll()之前需要先获取锁,在 finally 代码块中要释放锁;\n\n实战演示模拟三个线程,对其中两个线程分为一组绑定到condition1,剩下的一个线程单独一组绑定到condition2,main 线程再分别唤醒等待状态的各线程组.\n\n创建线程池\n\nprivate final ThreadFactory threadFactory &#x3D; ThreadFactoryBuilder.create().setNamePrefix(&quot;test&quot;).build();\n\nprivate final Executor executor &#x3D; new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() + 1, Runtime.getRuntime().availableProcessors() + 1,\n        10, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(16), threadFactory, new ThreadPoolExecutor.AbortPolicy());\n\n\n初始化CountDownLatch和ReentrantLock,注册两个condition.\n\n&#x2F;&#x2F;闭锁1  让3个子线程同时启动\nCountDownLatch startCdl &#x3D; new CountDownLatch(1);\n&#x2F;&#x2F;闭锁2  main线程等待子线程都执行完毕再结束\nCountDownLatch endCdl &#x3D; new CountDownLatch(3);\n&#x2F;&#x2F;同步锁\nReentrantLock lock &#x3D; new ReentrantLock(false);\n\nCondition condition1 &#x3D; lock.newCondition();\nCondition condition2 &#x3D; lock.newCondition();\n\n\n创建子线程,进入等待状态,等主线程唤醒\n\n&#x2F;**\n * 获取线程\n *\n * @param startCdl       开始同步器\n * @param endCdl         结束同步器\n * @param lock      锁\n * @param condition 条件\n * @return &#123;@link Thread&#125;\n *&#x2F;\nprivate Runnable getCallable(CountDownLatch startCdl, CountDownLatch endCdl, ReentrantLock lock, Condition condition) &#123;\n    return () -&gt; &#123;\n        try &#123;\n            &#x2F;&#x2F;让三个子线程同时启动\n            startCdl.await();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        lock.lock();\n        try &#123;\n            &#x2F;&#x2F;await会释放当前锁\n            condition.await();\n            log.info(&quot;线程&#123;&#125;被唤醒,时间:&#123;&#125;&quot;, Thread.currentThread().getName(),new Date());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            log.info(&quot;线程:&#123;&#125;执行完毕,释放同步锁&quot;,Thread.currentThread().getName());\n            &#x2F;&#x2F;被唤醒后,需要释放当前持有的锁\n            lock.unlock();\n            &#x2F;&#x2F;计数器为0主线程停止等待\n            endCdl.countDown();\n        &#125;\n    &#125;;\n&#125;\n&#x2F;&#x2F;启动三个子线程\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl,lock, condition2));\n\n\n主线程进行唤醒\n\nlog.info(&quot;Main线程开始执行....&quot;);\nstartCdl.countDown();\nlog.info(&quot;子线程正在等待....&quot;);\n\nlock.lock();\ncondition1.signalAll();\nlock.unlock();\ntry &#123;\n    &#x2F;&#x2F;主线程阻塞2秒 区分两次唤醒\n    Thread.sleep(2000);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\nlock.lock();\ncondition2.signal();\nlock.unlock();\ntry &#123;\n    log.info(&quot;等待三个子线程执行完毕&quot;);\n    endCdl.await();\n    log.info(&quot;main线程结束&quot;);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\n\n\n控制台输出. 可以看出两次唤醒相隔了两秒\n\n", "slug": "reentrant-lock", "date": "2023-05-08 07:05:39", "categories_index": "分布式", "tags_index": "ReentrantLock", "author_index": "倪传方"}, {"id": "e266b70dd1da3efc040f3fd65a612a8c", "title": "python高级学习日志第二、三天之网络编程", "content": "python 高级学习日志第二、三天之网络编程UDP 接收数据以及基于 UDP 的交易聊天器\n\n\n\n\n\n\n\n\n一个 Java 程序员，但是打算自学一下 python，所以把自己学到的东西记录在这里。也免得我自己忘记新学的，年纪大了真的很容易忘东西。\n哈哈，我喜欢边写程序边听歌\n\n\n上次记录的是怎么用 udp 来发送数据，通过网络调试助手按钮来模拟数据接收方，这次记录的是利用 udp 代码来接收数据，以及基于两份 python 代码的简易聊天器。\n\n\n\n\n\n\n\n\n\n话不多说直接开搞\n首先是单纯的用 udp 来接收数据，这里同样用网络调试助手来模拟发送数据，这个时候网络调试助手扮演的角色是发送数据方。\n\n\n\n\n\n\n\n\n\n利用 udp 接收数据有以下几个主要步骤：\n\n创建套接字\n绑定本地信息，包括本地 ip 以及分配端口号\n接收数据\n打印接收到的数据\n关闭套接字\n\nimport socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.接收数据\n    recv_data &#x3D; udp_socket.recvfrom(1024)\n    # 4.打印接收到的数据\n    print(recv_data)\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n在绑定本地信息过程中，套接字调用 bind()方法，其中绑定的内容是一个元组，(“,xxxx),元组的第一个值为本地 ip，不用些即可，代码运行时会自动填充，第二个是手动给这个接收的代码片运行分配一个端口号，可在 1024 至 65535 之间随意填写，除本机有程序已经在占用这个端口使用以外，这里我随机绑定的端口号是 7788，至于元组的第一个元素为什么带有引号，是因为他是一个字符串类型的参数。绑定好本地信息以后准备接受来自其它 udp 发送来的数据recv_data &#x3D; udp_socket.recvfrom(1024)调用套接字的 recvfrom 方法，1024 是指最大接收的数据量，这里用 1Kb 测试，最后把接收到的数据存进变量recv_data 里，然后运行程序：此时没有任何动作是因为程序正在等待接收数据然后打开网络调试助手新建一个 udp 来模拟发送数据同样的把相关配置做好，1 号处填上本地的 ip 地址，2 好处给网络调试助手启动服务器分配一个端口，3 号处也是填上本地 ip 地址，因为是同一台电脑发送数据和接收数据，4 号处填上代码里绑定的端口号，也就是 python 代码运行分配的端口号，所以整个过程相当于启动网络调试助手的 udp 作为数据发送方，然后填好要发给的另一方的信息。启动调试助手：输入测试发送的信息点击发送：回到代码运行处查看：可以看到显示的是一个大元组，大元组的第一个袁术是接收到的数据，在这里是中文的 ASCII 码，时 byte 类型的数据，然后后面跟着一组小元组，小元组的内容显而易见，小元组的第一个元素是数据发送方的 ip，第二个元素是数据发送方的端口号。接下来对代码做一些改变：\nimport socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.接收数据\n\n    recv_data &#x3D; udp_socket.recvfrom(1024)\n    # 解析元祖的消息内容\n    recv_msg &#x3D; recv_data[0]  # 存储接收到的数据\n    send_addr &#x3D; recv_data[1]  # 存储发送方的地址信息\n    # 4.打印接收到的数据\n    print(&quot;%s说:%s&quot; % (str(send_addr), recv_msg.decode(&quot;gbk&quot;)))\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n把原本的 recv_data 做一个拆分解析，把 recv_data 的第一个元素赋值给 recv_msg，表示收到的消息和数据。把 recv_data 的第二个元素赋值给 send_addr，是一个小元组，表示发送方的信息，其过程和 java 数组取值类似，最后分别做输出，需要注意的是，str 强转和接收到的数据转码。最后重新运行程序：等待收数据，然后在调试助手输入发送的数据：则代码最后运行结果如下：以上这种情况可以看出是收到一条数据则结束程序运行。接下来对代码进行改进能让代码持续收到书：\nimport socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.循环接收数据\n    while True:\n        recv_data &#x3D; udp_socket.recvfrom(1024)\n        # 解析元祖的消息内容\n        recv_msg &#x3D; recv_data[0]  # 存储接收到的数据\n        send_addr &#x3D; recv_data[1]  # 存储发送方的地址信息\n        # 4.打印接收到的数据\n        print(&quot;%s说:%s&quot; % (str(send_addr), recv_msg.decode(&quot;gbk&quot;)))\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n可以看出是将套接字收数据和打印数据作为循环体来循环，这个时候测试数据接收如下：在网络调试助手连续发送三条信息，代码运行都够收到以后，程序并未退出这个时候就做到了持续等待收数据和信息的效果。\n学习了 udp 收发数据以后，可以做一个基于 udp 的简单聊天器了，这个聊天器是发一句收一句的，因为还没有采取多线程的处理方式。具体代码如下，这个时候就不需要调试助手来充当角色了：\nimport socket\n\ndef send_msg(udp_scoket,dest_ip,dest_port):\n    &quot;&quot;&quot;&quot;发送消息&quot;&quot;&quot;\n    #获取要发送的内容\n    send_data&#x3D;input(&quot;请输入要发送的消息:&quot;)\n    udp_scoket.sendto(send_data.encode(&quot;gbk&quot;), (dest_ip, int(dest_port)))\n\n\ndef recv_msg(udp_scoket):\n    &quot;&quot;&quot;&quot;接收消息&quot;&quot;&quot;\n    recv_data&#x3D;udp_scoket.recvfrom(1024)\n    print(&quot;%s回消息说:%s&quot; %(str(recv_data[1]),recv_data[0].decode(&quot;gbk&quot;)))\n\n\ndef main():\n    #创建套接字\n    udp_scoket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n\n    #绑定信息\n    #绑定的是一个元组，里面存放ip信息和端口信息\n    udp_scoket.bind((&quot;&quot;,7788))\n    # 确定对方地址\n    dest_ip &#x3D; input(&quot;请输入对方的ip:&quot;)\n    dest_port &#x3D; input(&quot;请输入对方的port:&quot;)\n\n    #循环发送接收消息\n    while True:\n            #发送\n            send_msg(udp_scoket,dest_ip,dest_port)\n\n            #接受并显示\n            recv_msg(udp_scoket)\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n这里测试自己收发程序运行如下：可以看出是做到了自己收发消息了的，即在一个程序里，自己发送数据给自己自己接收数据并打印显示，当然也可以用两份程序分别演示一个发送数据，一个接收数据。具体看自己怎么理解和操作。\n\n\n\n\n\n\n\n\n\n下一次记录 tcp 的有关知识和实践\n", "slug": "python高级学习日志第二、三天之网络编程", "date": "2022-10-01 09:29:00", "categories_index": "Python", "tags_index": "Python网络编程", "author_index": "倪传方"}, {"id": "3ab3df2387b700f13887b79994864558", "title": "python高级学习日志第一天之网络编程", "content": "python 高级学习日志第一天之网络编程UDP 发送数据\n\n\n\n\n\n\n\n\n一个 Java 程序员，但是打算自学一下 python，所以把自己学到的东西记录在这里。也免得我自己忘记新学的，年纪大了真的很容易忘东西。\n哈哈，我喜欢边写程序边听歌\n\n\n\n\n\n\n\n\n\n中国人民真蒸汽\n\n\n这里直接记录的是我的实践内容\n首先是怎么利用简单的 udp 来发送数据？\n这里我用的编辑工具是&#x3D;&#x3D; Pycharm &#x3D;&#x3D;测试的工具是 &#x3D;&#x3D; 网络调试助手 &#x3D;&#x3D;其中网络调试助手有多种样式的，下对了能用的就 ok，我的就长这样子：利用 udp 进行简单的数据发送有四个步骤\n\n创建一个套接字\n从键盘读取你要发送的数据\n使用套接字发送你的数据\n关闭套接字\n\n那么在 python 中要用到套接字，就像 java 导包一样也需要导入其中的套接字使用模块，使用 Pycharm 会自动提示不劝导入，真滴是特别的方便了。\n接着在最后的位置给 python 设置一个启动器(main 方法)，类似，java 里的\npublic static void main(String[] args)&#123;&#125;\n\npython 里的写法是 main 方法：\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n\n在这个 main 函数缩进的位置上写上要执行的函数名就 ok按照刚刚说的流程走一遍：\n#引入套接字使用模块\nimport socket\n\n\n#自定义一个方法叫做main(),方法名随意\ndef main():\n    #1.创建一个套接字,叫做udp_socket,固定的创建写法\n    #其中SOCK_DGRAM是代表基于udp的套接字，无保障的\n    udp_socket&#x3D;socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    #2.从键盘读取输入数据,赋值给send_data变量\n    send_data &#x3D; input(&quot;请输入要发送的数据:&quot;)\n\n    #3.使用套接字发送数据\n    #udp_socket套接字已经创建,用其自带的方法即可以实现发送,并且把发送的数据编码，防止中文输入乱码\n    udp_socket.sendto(send_data.encode(&quot;gbk&quot;), (&quot;10.128.246.239&quot;, 6666))\n\n    #4.关闭套接字\n    udp_socket.close()\n\n\n#在main方法里执行main()函数\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\nok,这是一个简单的流程，其中 10.128.246.239 和 6666 分别是要接受数据方的 ip 地址和端口号，接收方也是一个 udp，只不过这个 udp 用来接收数据，在这里用网络调试助手来模拟接收数据的 udp 方。\n\n\n\n\n\n\n\n\n\n注意：套接字的 sendto 方法需要带两个参数，第一个是发送的数据，是 byte 类型的，第二个参数是一个元组，类似 java 里的数组，(ip 地址，端口号)，ip 地址是字符串类型的，端口号是整型的。\n接下来用网络调试助手模拟数据接收方，打开网络调试助手，如下新建一个 udp其中 ip 地址换成当前联网的 ip，window 下可以用 win+R，输入 cmd 开启命令模式输入 ipconfig 即可查看当前网络的 ip把这个 ip 地址输入到网络调试助手的设置区的本地 ip 位置，当然助手也能自动捕获，如图，用上这个就行然后设置一个端口号，自己设置就行了，大于 1024 小于 65535 就行，排除电脑上有程序在用这个端口以外。启动，最终如下图，这个时候通过代码里的参数配置，已经可以连接上这个接收器了，运行 python 程序点绿色按钮选择运行即可,运行如图：然后输入数据测试发送，输入后回车。这个时候回到网络调试助手可以看到：来自本机地址，因为是自己发给自己测试，这个端口发来的这个数据。\n这个时候开始想，能不能循环输入数据发送？答案是可以的，把发送数据执行的代码片作为循环体即可。然后可以简单地设置一下，当用户输入“exit”的时候，让用户结束发送。然后代码变成了这样，把从键盘获取数据到发送数据作为循环体。用 while True: 圈起来，也就是把循环体一段缩进，相当于 java 中的{}大括号。然后用 if 判断用户输入的是不是 exit 字符串，是的话，则跳出循环，直接执行关闭套接字操作，程序运行结束。\nimport socket\n\n\ndef main():\n    # 创建一个udp套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    while True:\n        # 从键盘获取数据\n        send_data &#x3D; input(&quot;请输入要发送的数据:&quot;)\n        # 如果输入的数据是exit。则推出程序\n        if send_data &#x3D;&#x3D; &quot;exit&quot;:\n            break\n        # 使用套接字发送数据\n        udp_socket.sendto(send_data.encode(&quot;gbk&quot;), (&quot;10.128.246.239&quot;, 6666))\n    # 关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n注意，if 里也用了缩进，就相当于 java 的{}\n运行程序:这个时候，可以循环发送数据。打开网络调试助手：它也循环收到了数据如果输入“exit”退出程序，结束发送。\n这里我们可能会注意到这个细节有两种端口，这个是因为代码运行了两次，每次运行都由操作系统随机分配端口，总而言之，一个应用程序需要运行，则需要一个端口，当然在代码里也可以绑定端口，套接字绑定端口的操作会在 udp 接收数据里记录。\n\n\n\n\n\n\n\n\n\n小白新学 python 之网络编程入门，大神勿喷下一次记录怎么利用 udp 接收数据？\n", "slug": "python高级学习日志第一天之网络编程", "date": "2022-09-30 14:22:00", "categories_index": "Python", "tags_index": "Python网络编程", "author_index": "倪传方"}, {"id": "c0ef1bb9822760c44fd32eaf5be50c8a", "title": "redis发布和订阅演示", "content": "Redis 第五期：redis 发布和订阅演示\n\n\n\n\n\n\n\n\nreis 的数据类型操作不再多说了，参考 redis 命令中文手册\n\n\n\n\n\n\n\n\n\n演示 redis 的发布和订阅分别在命令行客户端和编程客户端演示\n\n\n\n\n\n\n\n\n\n1.命令行客户端演示首先开启 redis 服务不多说了这里模拟一个发布者，三个订阅者在 redis src 下开启四个命令行终端，进入命令行模式，如下图：选取第一台作为发布者，其它三台作为订阅者\n\n\n\n\n\n\n\n\n\n首先在后三台终端上输入 SUBSCRIBE hello 命令（如果有密码得先 auth 密码命令输入密码）表示让这三台终端订阅 hello 这个频道，（分别回车）如图\n\n\n\n\n\n\n\n\n\n接着在第一台电脑上发布消息使用 publish+频道名+消息 命令回车\n结果如下（注意观察）\n三台终端同时跳出被发布的消息\n\n\n\n\n\n\n\n\n\n2.用 jedis 编程客户端来演示\n源码如下：同样要引入 jedis 节点 jar 包\n&lt;dependency&gt;\n      &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.9.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n消息订阅者角色\npackage com.lagoon;\n\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\n\n&#x2F;**\n * redis消息订阅者\n *&#x2F;\npublic class RedisSubscriber extends JedisPubSub &#123;\n\n    &#x2F;&#x2F;当接收到消息后触发该方法\n\n    @Override\n    public void onMessage(String channel, String message) &#123;\n        super.onMessage(channel, message);\n        System.out.println(&quot;频道[&quot;+channel+&quot;]发布了一条消息[&quot;+message+&quot;]&quot;);\n    &#125;\n\n    &#x2F;&#x2F;main方法接收消息，开启监听状态\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;连接到jedis\n        Jedis jedis&#x3D;new Jedis(&quot;192.168.5.131&quot;,6379);\n        jedis.auth(&quot;123456&quot;);\n\n        RedisSubscriber redisSubscriber&#x3D;new RedisSubscriber();\n\n        &#x2F;&#x2F;从频道订阅消息\n        jedis.subscribe(redisSubscriber,&quot;channel&quot;);\n    &#125;\n&#125;\n\n\n消息发布者角色\npackage com.lagoon;\n\nimport redis.clients.jedis.Jedis;\n\n&#x2F;&#x2F;消息发布者\npublic class RedisPublisher &#123;\n\n    public static void main(String[] args) &#123;\n        Jedis jedis&#x3D;new Jedis(&quot;192.168.5.131&quot;,6379);\n        jedis.auth(&quot;123456&quot;);\n\n        &#x2F;&#x2F;发布消息\n        jedis.publish(&quot;channel&quot;,&quot;大家好&quot;);\n\n        jedis.close();\n    &#125;\n&#125;\n\n\n开始演示，首先，运行消息订阅者类里的 main 方法程序处于监听状态，表示在等待消息发布\n接着运行发布消息类 main 方法如下运行完以后切换到消息订阅者运行窗口会发现收到了已经发布的消息\n这里甚至可以对代码进行一些改动，比如手动输入消息发布，不演示了\n", "slug": "redis发布和订阅演示", "date": "2019-09-07 08:33:00", "categories_index": "Redis", "tags_index": "redis发布与订阅", "author_index": "倪传方"}, {"id": "bdf4805eb354b82978231d675189aaca", "title": "Redis持久化的两种实现方式", "content": "Redis第七期：redis持久化的两种实现方式\n\n\n\n\n\n\n\n\n首先，什么是持久化，什么是redis的持久化持久化可以理解为存储，就是将数据存储到一个不会丢失的地方，如果把数据放在内存中，电脑关闭或重启数据就会丢失，所以放在内存中的数据不是持久化的，而放在磁盘就算是一种持久化。\n\n\n\n\n\n\n\n\n\nRedis的数据存储在内存中，内存是瞬时的，如果linux宕机或重启，又或者Redis崩溃或重启，所有的内存数据都会丢失，为解决这个问题，Redis提供两种机制对数据进行持久化存储，便于发生故障后能迅速恢复数据。\n\n\n\n\n\n\n\n\n\nredis提供两种持久化方式\n\n\n\n\n\n\n\n\n\n1.RDB方式Redis Database（RDB），就是在指定的时间间隔内将内存中的数据集快照写入磁盘，数据恢复时将快照文件直接再读到内存。RDB方式的数据持久化，仅需在redis.conf文件中配置即可配置文件redis.conf中搜索 SNAPSHOTTING其中配置格式：save 900 1save 300 10save 60 10000示例表示在900秒内发生1次改变就保存数据，类似如此那么保存数据在哪dbfilename：设置RDB的文件名，默认文件名为dump.rdbdir：指定RDB和AOF文件的目录以上这些都可以自定义配置容易发现其实redis默认开启RDB持久化的通过查找该文件名可以证明通过查找可以发现存在该文件，说明之前的操作都是RDB持久化了的，并在这个文件里被记录\n\n\n\n\n\n\n\n\n\nRDB持久化方式的优缺点优点：由于存储的是数据快照文件，恢复数据很方便，也比较快缺点：会丢失最后一次快照以后更改的数据\n\n\n\n\n\n\n\n\n\n如果你的应用能容忍一定数据的丢失，那么使用rdb是不错的选择如果你不能容忍一定数据的丢失，使用rdb就不是一个很好的选择\n\n\n\n\n\n\n\n\n\n由于需要经常操作磁盘，RDB 会经常 fork 出一个子进程。如果你的redis数据库很大的话，Fork 占用比较多的时间，并且可能会影响 Redis 暂停服务一段时间（millisecond 级别），如果你的数据库超级大并且你的服务器CPU比较弱，有可能是会达到一秒。\n\n\n\n\n\n\n\n\n\n2.第二种持久化方式AOF方式什么是AOF方式Append-only File（AOF），Redis每次接收到一条改变数据的命令时，它将把该命令写到一个AOF文件中（只记录写操作，读操作不记录），当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。AOF方式的数据持久化，仅需在redis.conf文件中配置即可在redis.conf配置文件中搜索APPEND ONLY MODE&gt;把appendonly 改为yes保存开启AOF持久化redis服务指定新配置开启先杀死服务进程以新配置开启redis服务&gt;在命令行终端写一些测试命令&gt;退出回到src目录下查找aof文件可以看见生成了持久化记录文件打开查看内容可见记录文件选择0号库，flushall清空所有，接着set k1 v1 ,set k2 v2aof文件只会记录写操作，不会记录读操作\n\n\n\n\n\n\n\n\n\n关于一些其配置appendfilename：指定AOF文件名，默认文件名为appendonly.aofappendfsync：配置向aof文件写命令数据的策略auto-aof-rewrite-percentage：当目前aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写，则以启动时的aof文件大小为依据auto-aof-rewrite-min-size：允许重写的最小AOF文件大小\n\n\n\n\n\n\n\n\n\n其中执行策略有no：不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），比较快但不是很安全always：每次执行写入都会执行同步，慢一些但是比较安全everysec：每秒执行一次同步操作，比较平衡，介于速度和安全之间\n\n\n\n\n\n\n\n\n\n总结append-only 文件是另一个可以提供完全数据保障的方案；AOF 文件会在操作过程中变得越来越大。比如，如果你做一百次加法计算，最后你只会在数据库里面得到最终的数值，但是在你的 AOF 里面会存在 100 次记录，其中 99 条记录对最终的结果是无用的；但 Redis 支持在不影响服务的前提下在后台重构 AOF 文件，让文件得以整理变小；可以同时使用这两种方式，redis默认优先加载aof文件；\n", "slug": "redis持久化的两种实现方式", "date": "2019-03-30 16:33:00", "categories_index": "Redis", "tags_index": "持久化", "author_index": "倪传方"}, {"id": "8539baf449cb37333713337188dfc881", "title": "redis对事务控制的实现", "content": "Redis第六期：redis对事务控制的实现\n\n\n\n\n\n\n\n\n首先，什么是事务？事务是指一系列操作步骤，这一系列的操作步骤，要么完全地执行，要么完全地不执行。比如微博中：A用户关注了B用户，那么A的关注人列表里面就会有B用户，B的粉丝列表里面就会有A用户。这个关注与被关注的过程是由一系列操作步骤构成：（1）A用户添加到B的粉丝列表里面（2）B用户添加到A的关注列表里面；这两个步骤必须全部执行成功，整个逻辑才是正确的，否则就会产生数据的错误，比如A用户的关注列表有B用户，但B的粉丝列表里没有A用户；要保证一系列的操作都完全成功，提出了事务控制的概念。\n\n\n\n\n\n\n\n\n\nredis事务Redis中的事务（transaction）是一组命令的集合，至少是两个或两个以上的命令，redis事务保证这些命令被执行时中间不会被任何其他操作打断。\nredis对事务控制的实现大致有以下几种情况：\n\n\n\n\n\n\n\n\n\n一，正常情况（测试中为避免冲突先flushall清空所有keys）1.用MULTI命令告诉Redis，接下来要执行的命令你先不要执行，而是把它们暂时存起来 （开启事务）开启事务，等待命令进入队列2.输入执行命令，进入命令队列queued返回值表示命令进入执行队列（注意此时还未执行）3.输入exec命令告知redis执行前面发送的命令（提交事务）可以看到exec后命令执行成功并且能够查询到相关值\n\n\n\n\n\n\n\n\n\n二，异常情况1.开启事务2.输入一个正常命令成功进入队列等待执行3.输入一个错误命令首先返回语法错误4.最后提交事务查看提交事务失败\n\n\n\n\n\n\n\n\n\n三，例外情况1.开启事务2.输入一个正常命令3.输入一个正常命令（本身没有语法错误）成功进入执行等待队列4.提交事务提示第一个命令执行成功第二个命令执行出错事务依然提交了，k5的值被设置为v5，自增操作执行失败，但整个事务没有回滚.\n\n\n\n\n\n\n\n\n\n四，放弃情况1.开启事务2.输入两个正常命令进入执行队列3.放弃事务放弃事务后，k6，k7并没有被赋值放弃事务，则命令队列不会被执行\n\n\n\n\n\n\n\n\n\n五，复杂情况这里要提到悲观锁和乐观锁概念\n\n\n\n\n\n\n\n\n\n悲观锁悲观锁(Pessimistic Lock)， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改该数据，所以每次在拿数据的时候都会先上锁，这样别人想拿这个数据就会block阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，让别人无法操作该数据。\n\n\n\n\n\n\n\n\n\n乐观锁乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改该数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这条数据，一般使用版本号机制进行判断。乐观锁适用于多读的应用类型，这样可以提高吞吐量。\n\n\n\n\n\n\n\n\n\n乐观锁大多数情况是基于数据版本号（version）的机制实现的。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个“version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据，不予更新。\n\n\n\n\n\n\n\n\n\n图例：\n\n\n\n\n\n\n\n\n\nredis的watch机制实现乐观锁监视一个(或多个) key ，如果在事务exec执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断这里开启两个终端来演示1.执行一个正常命令2.开启对money的监控3.开启事务4.在事务等待命令的这段时间里，在另一个终端里改变money值（注意回车）5.接着在第一个终端里事务改写money值6.提交事务查看事务提交不了，因为发现在事务等待过程中，money值被监控已经发小被修改了，所以无法提交事务7.查看money值发现值最终是另一个终端改动影响的\n", "slug": "redis对事务控制的实现", "date": "2019-03-25 19:26:00", "categories_index": "Redis", "tags_index": "事务控制", "author_index": "倪传方"}, {"id": "4ab18f90b2937be74536568e1919dbe5", "title": "Redis的一个小坑", "content": "Redis 的一个小坑\n\n\n\n\n\n\n\n\n又忘了，修改了 redis 的配置文件就一定要重新制定配置文件启动太坑了，记录一下测试成功\npackage com.lagoon;\n\nimport redis.clients.jedis.Jedis;\n\n&#x2F;**\n * Hello world!\n *\n *&#x2F;\npublic class App\n&#123;\n    public static void main( String[] args )\n    &#123;\n        &#x2F;&#x2F;根据端口和ip连接redis\n        Jedis jedis&#x3D;new Jedis(&quot;192.168.5.128&quot;,6379);\n        &#x2F;&#x2F;输入密码\n        jedis.auth(&quot;123456&quot;);\n        System.out.println(&quot;服务正在运行&quot;+jedis.ping());\n    &#125;\n&#125;\n\n\n\n", "slug": "Redis的一个小坑", "date": "2019-03-23 22:23:00", "categories_index": "Redis", "tags_index": "tips", "author_index": "倪传方"}, {"id": "c1b8e397764a04b15b42b94eec3a8f01", "title": "有关Docker容器架构", "content": "有关Docker容器架构\n\n\n\n\n\n\n\n\n\nDocker客户端与服务器Docker是一个客户端-服务器的（C&#x2F;S）架构程序，Docker的客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具和一整套RESTful API。你可以在同一台主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。\n\n\n\n\n\n\n\n\n\nDocker镜像镜像（Image）是Docker中的一个模板。通过Docker镜像来创建Docker容器，一个镜像可以创造出多个容器。镜像是由一系列指令一步一步构建出来，例如：\n\n添加一个文件\n执行一个命令\n打开一个窗口\n\n\n\n\n\n\n\n\n\n\nj镜像与容器的关系类似于java中类与对象的关系镜像体积很小，非常“便携”，易于分享，存储和更新。\n\n\n\nDocker\nJava\n\n\n\n镜像\n类\n\n\n容器\n对象\n\n\nclass Emp&#123;&#125; &#x2F;&#x2F;镜像：\nEmp e1 &#x3D; new Emp(); &#x2F;&#x2F;容器1\nEmp e2 &#x3D; new Emp(); &#x2F;&#x2F;容器2\n\n\n\n\n\n\n\n\n\n\nDocker容器容器（Container）是基于镜像创建的运行的实例，一个容器中可以运行一个或者多个应用程序（jdk+开发的java应用程序）。Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。可以认为，镜像是Docker生命周期的构建或者打包阶段，而容器则是启动或者执行阶段。可以理解容器中有包含：一个精简版的Linux环境+要运行的应用程序\n\n\n\n\n\n\n\n\n\nDocker仓库仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库（Repository）和仓库注册服务器（Registry）混为一谈，但并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。仓库分为公有仓库（Public）和私有仓库（Private）两种。Docker公司运营的公共仓库叫做 Docker Hub （https://hub.docker.com/），存放了数量庞大的镜像供用户下载。用户可以在Docker Hub注册账号，分享并保存自己的镜像。（说明：在Docker Hub下载镜像巨慢）国内的公有仓库包括阿里云 、网易云 等，可以提供大陆用户更稳定快速的访问。当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。\n\n", "slug": "有关Docker容器架构", "date": "2019-03-22 10:29:00", "categories_index": "Devops", "tags_index": "Docker", "author_index": "倪传方"}]