[{"id": "b9663f58f18133b35bfe243f3e916a80", "title": "Hello World", "content": "\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer introubleshooting or you can ask me on GitHub.\n1. 快速开始创建新文档hexo new &quot;My New Post&quot;\n\nMore info: Writing\n启动本地服务hexo server\n\nMore info: Server\n构建静态文件hexo generate\n\nMore info: Generating\n部署hexo deploy\n\nMore info: Deployment\n2. Markdown 自定义容器所有的自定义容器都使用这种格式:\n:::[type] [title]\n文本内容\n:::\n\n\ntype 是容器的类型\ntitle 是可选的,可以用来重命名容器的标题\n\nTip 容器:::tip\nNormal Tips Container\n:::\n\n\n如果你不想使用默认的标题 TIP，你可以使用以下方法重命名你的容器标题:\n:::tip Custom header\n\nCustom header\n\n- tips content\n- tips new line\n\n:::\n\n\nWarning 容器:::warning\nWarning!!!\n:::\n\n\nDanger 容器:::danger\nDanger!!!\n:::\n\n\nDetails 容器这是一种特殊类型的容器。如果你看过 GitHub 中的 details 容器，你可能会猜出它的功能是什么。\n是的，您可以隐藏某些内容，并单击来展开它。\n:::details Click to see more\n\nFusce rutrum venenatis eros in hendrerit. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nullam eget risus egestas, aliquet ipsum sed, volutpat tortor. Proin finibus tortor ac mauris finibus rutrum. Nullam tincidunt arcu eu urna ullamcorper, eu ultricies turpis ornare. Morbi id sollicitudin orci. Proin lobortis vehicula nibh a ornare. Cras sodales eu ligula quis fermentum. Proin eu ultrices leo, quis iaculis justo. Sed dictum, nulla sit amet imperdiet commodo, libero sapien semper justo, ut lobortis elit nunc vitae ante. Nullam lobortis odio quam, ac condimentum elit posuere vitae. Sed ornare, odio et rutrum varius, lorem eros gravida urna, in pharetra sapien justo non magna.\n\n- details content\n- details new line\n\n&#96;console.log(&#39;hello world&#39;)&#96;\n\n:::\n\n关闭状态:\n\n展开状态:\n\n", "slug": "hello-world", "date": "2023-05-11 08:19:00", "categories_index": "欢迎页", "tags_index": "template", "author_index": "倪传方"}, {"id": "1269f6284fcda69dd94df081174c6509", "title": "个人简历", "content": "个人信息\n倪传方&#x2F;男&#x2F;1994.08\n本科&#x2F;合肥工业大学-工程力学\n工作年限: 4 年\n工作单位: 鸿程计算机系统有限公司-至今\nGithub: https://github.com/nichuanfang\nGitee: https://gitee.com/JayChou_sf\n期望职位: Java 开发工程师,python 开发工程师\n当前薪资: 11k\n期望薪资: 税前月薪 15k+\n期望城市：武汉&#x2F;合肥\n\n联系方式\n手机: 18326186224\nEmail: &#102;&#49;&#56;&#x33;&#x32;&#54;&#x31;&#x38;&#54;&#x32;&#50;&#x34;&#64;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d; &#x2F; &#x31;&#50;&#57;&#x30;&#50;&#55;&#52;&#x39;&#55;&#x32;&#64;&#113;&#x71;&#x2e;&#99;&#111;&#109;\n微信号: ncf08209270\n\n技能清单\n计算机基础：熟练掌握计算机网络、数据结构和算法、操作系统，了解计算机组成原理\nLinux：熟练使用 Linux，有 Linux 下开发部署项目的实际经验\nJava：熟练掌握 Java 基础、集合、并发、熟悉 JVM 常见概念，有过 JVM 排查问题和调优的经历\n开发工具：熟练使用 Maven、Git、IDEA、Navicat、VS Code、Docker 等开发工具。\n数据库：掌握 MySQL 数据库以及常见优化手段（比如索引、SQL 优化、读写分离、分库分表），有 Redis 实战经验（搭建过 Redis 集群），了解 Oracle,MongoDB\n搜索引擎：了解 Elasticsearch 的使用及原理\n框架：\n熟练掌握 Spring、Spring MVC、SpringBoot、MyBatis、JPA、Spring Security、Junit 等基础开发框架\n了解 Netty 网络编程\n掌握工作流框架 Activiti\n\n\n分布式：\n掌握 RPC（dubbo,Feign）、分布式事务（Seata）、注册中心+配置中心（Nacos）、负载均衡(Ribbon)、 分布式链路追踪（Sleuth）、分布式 ID（UUID、Snowflake）、消息 队列（RabbitMQ）、限流熔断（Sentinel）的使用及原理\n熟悉 Spring Cloud／Spring Cloud Alibaba 全家桶常见组件的使用，有微服务架构项目开发经验\n\n\n文档相关: 熟练掌握文档语法 Markdown,熟悉设计工具 Visio,掌握 git 提交、pr 以及发版规范\n前端：掌握 HTML5、CSS、Javascript、Bootstrap、Ajax，了解 ES5&#x2F;ES6、TypeScript，有 AngularJs、Vue 的实际开发经验\nDevops：掌握 Jenkins,GitHub Actions workflows,Git Webhook,熟悉 CI／CD 流程\n有微信公众平台,开放平台的开发经验(公众号)\n其他技术栈: 熟悉 python 相关的技术栈,包括爬虫工具 selenium、bs4,http 服务器框架 Flask、hug ,图片处理 Pillow、opencv、OCR(tesseract)等\n\n工作经历鸿程计算机系统有限公司 （ 2019 年 8 月 ~ 2023 年 4 月 ）财务共享平台我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。\n统一流程引擎平台流程引擎\n生产安全监控我在此项目负责了哪些工作，分别在哪些地方做得出色&#x2F;和别人不一样&#x2F;成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。\n其他项目（每个公司写 2~3 个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）\n杭州远达科技 （ 2018 年 7 月 ~ 2019 年 6 月 ）微信点餐平台\n参与商家入驻功能的开发\nMyBatis 实现后台商家列表的读取，商家所在城区、所属的商品栏目的获取，并封装成 JSON 数据，为前端提供数据接口\n使用 Ajax 实现商家入驻时选择区域、类型\n使用 Spring 实现店铺图片的上传\n通过 Maven 进行项目管理，使用 Git 等工具辅助开发\n店铺信息更改功能等实现，使店主能够在管理后台实现店铺联系方式等基本信息的更改\n实现店铺活动的添加，使用 TreeView 实现对活动类型和所属区域、店铺的展示\n使用 vue 进行快速开发，实现通过手机浏览器访问店铺信息修改页面\n\n", "slug": "resume", "date": "2023-05-10 07:18:05", "categories_index": "作品集", "tags_index": "resume", "author_index": "倪传方"}, {"id": "99f059eccc4d62d721a5fd588d745cd9", "title": "【Java】java23种设计模式案例之命令模式", "content": "\n\n【Java】java23 种设计模式案例之命令模式\n\n\n\n\n\n\n\n\n命令模式定义参考\n\n\n\n\n\n\n\n\n\n例子: 源代码\n3 种案例\n\n\n\n\n\n\n\n\n\n1.Command 案例问题描述：一个指挥官请求（命令）三连偷袭敌人代码\npackage com.lagoon.command;\n\n&#x2F;**\n * 问题描述：一个指挥官请求（命令）三连偷袭敌人\n * 这个类扮演的是接收者角色\n *&#x2F;\npublic class CompanyArmy &#123;\n\n    public void sneakAttack()&#123;\n        System.out.println(&quot;我们知道如何偷袭敌人，保证完成任务！&quot;);\n    &#125;\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 这个接口扮演的是命令接口角色\n *&#x2F;\npublic interface Command &#123;\n    public abstract void execute();\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 这个类扮演的是具体命令的角色\n *&#x2F;\npublic class ConcreteCommand implements Command&#123;\n\n    CompanyArmy companyArmy;  &#x2F;&#x2F;含有接收者的引用\n    ConcreteCommand(CompanyArmy companyArmy)&#123;\n        this.companyArmy&#x3D;companyArmy;\n    &#125;\n\n    @Override\n    public void execute() &#123;  &#x2F;&#x2F;封装着指挥官的请求\n        companyArmy.sneakAttack();  &#x2F;&#x2F;偷袭敌人\n\n    &#125;\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 这个类代表请求者，也就是指挥官的角色\n *&#x2F;\npublic class ArmySuperior &#123;\n\n    Command command;  &#x2F;&#x2F;用来存放具体命令的引用\n    public void setCommand(Command command)&#123;\n        this.command&#x3D;command;\n    &#125;\n    public void startExecuteCommand()&#123;\n        command.execute();\n    &#125;\n&#125;\n\n\npackage com.lagoon.command;\n\n&#x2F;**\n * 该类为main方法，演示一个指挥官下发命令如何请求三连偷袭敌人\n *&#x2F;\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建接收者\n        CompanyArmy 三连&#x3D;new CompanyArmy();\n        &#x2F;&#x2F;创建具体命令并指定接收者\n        Command command&#x3D;new ConcreteCommand(三连);\n        &#x2F;&#x2F;创建请求者\n        ArmySuperior 指挥官&#x3D;new ArmySuperior();\n        &#x2F;&#x2F;下发命令\n        指挥官.setCommand(command);\n        &#x2F;&#x2F;开始执行命令\n        指挥官.startExecuteCommand();\n        &#x2F;&#x2F;执行结果：输出语句，我们知道如何偷袭敌人，保证完成任务！\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n2.Dir 命令，演示命令模式的可撤销操作问题描述：该问题描述的是请求者请求在硬盘上建立目录，还可以撤销请求，这就要求接收者不仅可以在硬盘上建立目录，也可以删除上一次请求所建立的目录代码：\npackage com.lagoon.Dir;\n\n&#x2F;**\n * 该问题描述的是请求者请求在硬盘上建立目录，还可以撤销请求，这就要求接收者不仅可以在硬盘上建立目录，也可以删除上一次请求所建立的目录\n * 该类扮演的是接收者角色，即既可以新增目录，也可以删除目录\n *&#x2F;\nimport java.io.*;\npublic class MakeDir &#123;\n    public void createDir(String name)&#123;\n        File dir&#x3D;new File(name);\n        dir.mkdir();\n    &#125;\n\n    public void deleteDir(String name)&#123;\n        File dir&#x3D;new File(name);\n        dir.delete();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Dir;\n\n&#x2F;**\n * 该类为命令接口类,代表既可以执行命令，也可以撤销收回命令\n *&#x2F;\npublic interface Command &#123;\n    public abstract void execute(String name);\n    public abstract void undo();\n&#125;\n\n\npackage com.lagoon.Dir;\n\nimport java.util.ArrayList;\n\n&#x2F;**\n *该类为具体命令类\n *&#x2F;\npublic class ConcreteCommand implements Command&#123;\n    ArrayList&lt;String&gt; dirNameList;\n    MakeDir makeDir;\n    ConcreteCommand(MakeDir makeDir)&#123;\n        dirNameList&#x3D;new ArrayList&lt;String&gt;();\n        this.makeDir&#x3D;makeDir;\n    &#125;\n    @Override\n    public void execute(String name) &#123;\n        makeDir.createDir(name);\n        dirNameList.add(name);\n\n    &#125;\n\n    @Override\n    public void undo() &#123;\n        if (dirNameList.size()&gt;0)&#123;\n            int m&#x3D;dirNameList.size();\n            String str&#x3D;dirNameList.get(m-1);\n            makeDir.deleteDir(str);\n            dirNameList.remove(m-1);\n        &#125;\n        else\n            System.out.println(&quot;没有需要撤销的操作&quot;);\n\n    &#125;\n&#125;\n\n\npackage com.lagoon.Dir;\n\n&#x2F;**\n * 该类为请求者角色\n *&#x2F;\npublic class RequestMakeDir &#123;\n    Command command;\n    public void setCommand(Command command)&#123;\n        this.command&#x3D;command;\n    &#125;\n    public void startExecuteCommand(String name)&#123;\n        command.execute(name);\n    &#125;\n    public void undoCommand()&#123;\n        command.undo();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Dir;\n\nimport java.util.Iterator;\n\n&#x2F;**\n * 该类为发射类\n *&#x2F;\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;创建接收者\n        MakeDir makeDir&#x3D;new MakeDir();\n        &#x2F;&#x2F;创建具体命令并指定接收者\n        Command command&#x3D;new ConcreteCommand(makeDir);\n        RequestMakeDir requestMakeDir&#x3D;new RequestMakeDir();\n        requestMakeDir.setCommand(command);\n        &#x2F;&#x2F;建立名字是java的目录\n        requestMakeDir.startExecuteCommand(&quot;java&quot;);\n        &#x2F;&#x2F;建立名字是c的目录\n        requestMakeDir.startExecuteCommand(&quot;c&quot;);\n        &#x2F;&#x2F;建立名字是c++的目录\n        requestMakeDir.startExecuteCommand(&quot;c++&quot;);\n        &#x2F;&#x2F;撤销命令，删除名字是c++的目录\n        requestMakeDir.undoCommand();\n        &#x2F;&#x2F;撤销命令，删除名字是c的目录\n        requestMakeDir.undoCommand();\n\n        &#x2F;&#x2F;查看当前列表里的目录\n        Iterator&lt;String&gt; iterator &#x3D; ((ConcreteCommand) command).dirNameList.iterator();\n        if (iterator.hasNext())&#123;\n            System.out.println(iterator.next());\n        &#125;\n\n        &#x2F;&#x2F;运行结果，输出一个列表目录，java，说明其他被撤销成功\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n3.Letter 案例问题描述：请求者可以请求只输出英文字母表，俄文字母表或 1-n 之间的偶数也可以请求三种都输出代码：\npackage com.lagoon.Letter;\n\n&#x2F;**\n * 该文件夹演示宏命令\n * 宏命令也是一个具体命令，只不过他包含了其他命令的引用\n * 执行一个宏命令，相当于执行了许多的具体命令\n * 该类为接收者角色\n * 问题描述：请求者可以请求只输出英文字母表，俄文字母表或1-n之间的偶数\n * 也可以请求三种都输出\n *&#x2F;\npublic class PrintLetter &#123;\n    public void printEnglish()&#123;\n        for (char c&#x3D;&#39;a&#39;;c&lt;&#x3D;&#39;z&#39;;c++)&#123;\n            System.out.println(&quot; &quot;+c);\n        &#125;\n    &#125;\n\n    public void printRussian()&#123;\n        for (char c&#x3D;&#39;а&#39;;c&lt;&#x3D;&#39;я&#39;;c++)&#123;\n            System.out.println(&quot; &quot;+c);\n        &#125;\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;**\n * 命令接口类\n *&#x2F;\npublic interface Command &#123;\n    public abstract void execute();\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;&#x2F;具体命令之输出英文字母表命令\npublic class PrintEnglishCommand implements Command&#123;\n    PrintLetter letter;\n\n    public PrintEnglishCommand(PrintLetter letter) &#123;\n        this.letter &#x3D; letter;\n    &#125;\n    public void execute()&#123;\n        letter.printEnglish();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;&#x2F;具体命令之输出俄文字母表\npublic class PrintRussianCommand implements Command&#123;\n    PrintLetter letter;\n\n    public PrintRussianCommand(PrintLetter letter) &#123;\n        this.letter &#x3D; letter;\n    &#125;\n\n    @Override\n    public void execute() &#123;\n        letter.printRussian();\n    &#125;\n\n&#125;\n\n\npackage com.lagoon.Letter;\n\nimport java.util.ArrayList;\n\n&#x2F;&#x2F;宏命令，执行所有命令\npublic class MacroCommand implements Command&#123;\n\n    ArrayList&lt;Command&gt; commandArrayList;  &#x2F;&#x2F;把所有的命令存进数组\n\n    public MacroCommand(ArrayList&lt;Command&gt; commandArrayList) &#123;\n        this.commandArrayList &#x3D; commandArrayList;\n    &#125;\n\n    @Override\n    public void execute() &#123;\n        for (int k&#x3D;0;k&lt;commandArrayList.size();k++)&#123;\n            Command command&#x3D;commandArrayList.get(k);  &#x2F;&#x2F;循环定位到命令\n            command.execute(); &#x2F;&#x2F;执行命令\n        &#125;\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\n&#x2F;&#x2F;该类为请求者角色\npublic class RequestMakedir &#123;\n    Command command;\n\n    public void setCommand(Command command) &#123;\n        this.command &#x3D; command;\n    &#125;\n    public void startExecuteCommand()&#123;\n        command.execute();\n    &#125;\n&#125;\n\n\npackage com.lagoon.Letter;\n\nimport java.util.ArrayList;\n\n&#x2F;&#x2F;发射类，main方法\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;Command&gt; list&#x3D; new ArrayList&lt;&gt;();\n        &#x2F;&#x2F;创建请求者\n        RequestMakedir requestMakedir&#x3D;new RequestMakedir();\n        &#x2F;&#x2F;创建命令具体接收者\n        Command command1&#x3D;new PrintEnglishCommand(new PrintLetter());\n        Command command2&#x3D;new PrintRussianCommand(new PrintLetter());\n\n        &#x2F;&#x2F;整合命令\n        list.add(command1);\n        list.add(command2);\n\n\n        &#x2F;&#x2F;创宏命令\n        Command macroCommand&#x3D;new MacroCommand(list);\n\n        System.out.println(&quot;单独输出英文字母表:&quot;);\n        requestMakedir.setCommand(command1);\n        requestMakedir.startExecuteCommand();\n\n        System.out.printf(&quot;%n用一个宏命令输出所有:%n&quot;);\n        requestMakedir.setCommand(macroCommand);\n        requestMakedir.startExecuteCommand();\n    &#125;\n&#125;\n\n", "slug": "【Java】java23种设计模式案例之命令模式", "date": "2020-12-01 10:50:00", "categories_index": "Java", "tags_index": "设计模式", "author_index": "倪传方"}, {"id": "2e5004b8a8ff49317aa7f3e9b71f74cf", "title": "可重入锁ReentrantLock高级特性", "content": "ReentrantLock提供了Synchronized不具备的三个高级特性\n公平锁\n\n&#x2F;**\n * Creates an instance of &#123;@code ReentrantLock&#125;.\n * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.\n *&#x2F;\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync();\n&#125;\n\n\n等待可中断\n\n&#x2F;**\n * 尝试锁定\n *\n * @param timeout 超时时间\n * @param unit    单位\n * @return boolean 尝试获取锁的结果\n * @throws InterruptedException 中断异常\n *&#x2F;\npublic boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n&#125;\n\n\n\n\n\n\n\n提示\n条件通知,一把锁可以生成多个条件,每个条件可以对应一个线程分组,可以通过 condition 对象来进行分组等待和唤醒,解决了synchronized关键字只能notifyAll()的问题\n\npublic Condition newCondition() &#123;\n    return sync.newCondition();\n&#125;\n\n\n\n\n\n\n\n\n注意\nReentrantLock条件通知使用注意点\n\n\n每个 condition 可以绑定若干个线程,如果需要多个 condition 请先对线程进行分组;\n使用await()和signal()或者signalAll()之前需要先获取锁,在 finally 代码块中要释放锁;\n\n实战演示模拟三个线程,对其中两个线程分为一组绑定到condition1,剩下的一个线程单独一组绑定到condition2,main 线程再分别唤醒等待状态的各线程组.\n\n创建线程池\n\nprivate final ThreadFactory threadFactory &#x3D; ThreadFactoryBuilder.create().setNamePrefix(&quot;test&quot;).build();\n\nprivate final Executor executor &#x3D; new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() + 1, Runtime.getRuntime().availableProcessors() + 1,\n        10, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(16), threadFactory, new ThreadPoolExecutor.AbortPolicy());\n\n\n初始化CountDownLatch和ReentrantLock,注册两个condition.\n\n&#x2F;&#x2F;闭锁1  让3个子线程同时启动\nCountDownLatch startCdl &#x3D; new CountDownLatch(1);\n&#x2F;&#x2F;闭锁2  main线程等待子线程都执行完毕再结束\nCountDownLatch endCdl &#x3D; new CountDownLatch(3);\n&#x2F;&#x2F;同步锁\nReentrantLock lock &#x3D; new ReentrantLock(false);\n\nCondition condition1 &#x3D; lock.newCondition();\nCondition condition2 &#x3D; lock.newCondition();\n\n\n创建子线程,进入等待状态,等主线程唤醒\n\n&#x2F;**\n * 获取线程\n *\n * @param startCdl       开始同步器\n * @param endCdl         结束同步器\n * @param lock      锁\n * @param condition 条件\n * @return &#123;@link Thread&#125;\n *&#x2F;\nprivate Runnable getCallable(CountDownLatch startCdl, CountDownLatch endCdl, ReentrantLock lock, Condition condition) &#123;\n    return () -&gt; &#123;\n        try &#123;\n            &#x2F;&#x2F;让三个子线程同时启动\n            startCdl.await();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        lock.lock();\n        try &#123;\n            &#x2F;&#x2F;await会释放当前锁\n            condition.await();\n            log.info(&quot;线程&#123;&#125;被唤醒,时间:&#123;&#125;&quot;, Thread.currentThread().getName(),new Date());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            log.info(&quot;线程:&#123;&#125;执行完毕,释放同步锁&quot;,Thread.currentThread().getName());\n            &#x2F;&#x2F;被唤醒后,需要释放当前持有的锁\n            lock.unlock();\n            &#x2F;&#x2F;计数器为0主线程停止等待\n            endCdl.countDown();\n        &#125;\n    &#125;;\n&#125;\n&#x2F;&#x2F;启动三个子线程\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl,lock, condition2));\n\n\n主线程进行唤醒\n\nlog.info(&quot;Main线程开始执行....&quot;);\nstartCdl.countDown();\nlog.info(&quot;子线程正在等待....&quot;);\n\nlock.lock();\ncondition1.signalAll();\nlock.unlock();\ntry &#123;\n    &#x2F;&#x2F;主线程阻塞2秒 区分两次唤醒\n    Thread.sleep(2000);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\nlock.lock();\ncondition2.signal();\nlock.unlock();\ntry &#123;\n    log.info(&quot;等待三个子线程执行完毕&quot;);\n    endCdl.await();\n    log.info(&quot;main线程结束&quot;);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\n\n\n控制台输出. 可以看出两次唤醒相隔了两秒\n\n", "slug": "reentrant-lock", "date": "2023-05-08 07:05:39", "categories_index": "分布式", "tags_index": "ReentrantLock", "author_index": "倪传方"}, {"id": "e266b70dd1da3efc040f3fd65a612a8c", "title": "python高级学习日志第二、三天之网络编程", "content": "\n\npython 高级学习日志第二、三天之网络编程UDP 接收数据以及基于 UDP 的交易聊天器\n\n\n\n\n\n\n\n\n一个 Java 程序员，但是打算自学一下 python，所以把自己学到的东西记录在这里。也免得我自己忘记新学的，年纪大了真的很容易忘东西。\n哈哈，我喜欢边写程序边听歌\n\n\n上次记录的是怎么用 udp 来发送数据，通过网络调试助手按钮来模拟数据接收方，这次记录的是利用 udp 代码来接收数据，以及基于两份 python 代码的简易聊天器。\n\n\n\n\n\n\n\n\n\n话不多说直接开搞\n首先是单纯的用 udp 来接收数据，这里同样用网络调试助手来模拟发送数据，这个时候网络调试助手扮演的角色是发送数据方。\n\n\n\n\n\n\n\n\n\n利用 udp 接收数据有以下几个主要步骤：\n\n创建套接字\n绑定本地信息，包括本地 ip 以及分配端口号\n接收数据\n打印接收到的数据\n关闭套接字\n\nimport socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.接收数据\n    recv_data &#x3D; udp_socket.recvfrom(1024)\n    # 4.打印接收到的数据\n    print(recv_data)\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n在绑定本地信息过程中，套接字调用 bind()方法，其中绑定的内容是一个元组，(“,xxxx),元组的第一个值为本地 ip，不用些即可，代码运行时会自动填充，第二个是手动给这个接收的代码片运行分配一个端口号，可在 1024 至 65535 之间随意填写，除本机有程序已经在占用这个端口使用以外，这里我随机绑定的端口号是 7788，至于元组的第一个元素为什么带有引号，是因为他是一个字符串类型的参数。绑定好本地信息以后准备接受来自其它 udp 发送来的数据recv_data &#x3D; udp_socket.recvfrom(1024)调用套接字的 recvfrom 方法，1024 是指最大接收的数据量，这里用 1Kb 测试，最后把接收到的数据存进变量recv_data 里，然后运行程序：此时没有任何动作是因为程序正在等待接收数据然后打开网络调试助手新建一个 udp 来模拟发送数据同样的把相关配置做好，1 号处填上本地的 ip 地址，2 好处给网络调试助手启动服务器分配一个端口，3 号处也是填上本地 ip 地址，因为是同一台电脑发送数据和接收数据，4 号处填上代码里绑定的端口号，也就是 python 代码运行分配的端口号，所以整个过程相当于启动网络调试助手的 udp 作为数据发送方，然后填好要发给的另一方的信息。启动调试助手：输入测试发送的信息点击发送：回到代码运行处查看：可以看到显示的是一个大元组，大元组的第一个袁术是接收到的数据，在这里是中文的 ASCII 码，时 byte 类型的数据，然后后面跟着一组小元组，小元组的内容显而易见，小元组的第一个元素是数据发送方的 ip，第二个元素是数据发送方的端口号。接下来对代码做一些改变：\nimport socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.接收数据\n\n    recv_data &#x3D; udp_socket.recvfrom(1024)\n    # 解析元祖的消息内容\n    recv_msg &#x3D; recv_data[0]  # 存储接收到的数据\n    send_addr &#x3D; recv_data[1]  # 存储发送方的地址信息\n    # 4.打印接收到的数据\n    print(&quot;%s说:%s&quot; % (str(send_addr), recv_msg.decode(&quot;gbk&quot;)))\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n把原本的 recv_data 做一个拆分解析，把 recv_data 的第一个元素赋值给 recv_msg，表示收到的消息和数据。把 recv_data 的第二个元素赋值给 send_addr，是一个小元组，表示发送方的信息，其过程和 java 数组取值类似，最后分别做输出，需要注意的是，str 强转和接收到的数据转码。最后重新运行程序：等待收数据，然后在调试助手输入发送的数据：则代码最后运行结果如下：以上这种情况可以看出是收到一条数据则结束程序运行。接下来对代码进行改进能让代码持续收到书：\nimport socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.循环接收数据\n    while True:\n        recv_data &#x3D; udp_socket.recvfrom(1024)\n        # 解析元祖的消息内容\n        recv_msg &#x3D; recv_data[0]  # 存储接收到的数据\n        send_addr &#x3D; recv_data[1]  # 存储发送方的地址信息\n        # 4.打印接收到的数据\n        print(&quot;%s说:%s&quot; % (str(send_addr), recv_msg.decode(&quot;gbk&quot;)))\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n可以看出是将套接字收数据和打印数据作为循环体来循环，这个时候测试数据接收如下：在网络调试助手连续发送三条信息，代码运行都够收到以后，程序并未退出这个时候就做到了持续等待收数据和信息的效果。\n学习了 udp 收发数据以后，可以做一个基于 udp 的简单聊天器了，这个聊天器是发一句收一句的，因为还没有采取多线程的处理方式。具体代码如下，这个时候就不需要调试助手来充当角色了：\nimport socket\n\ndef send_msg(udp_scoket,dest_ip,dest_port):\n    &quot;&quot;&quot;&quot;发送消息&quot;&quot;&quot;\n    #获取要发送的内容\n    send_data&#x3D;input(&quot;请输入要发送的消息:&quot;)\n    udp_scoket.sendto(send_data.encode(&quot;gbk&quot;), (dest_ip, int(dest_port)))\n\n\ndef recv_msg(udp_scoket):\n    &quot;&quot;&quot;&quot;接收消息&quot;&quot;&quot;\n    recv_data&#x3D;udp_scoket.recvfrom(1024)\n    print(&quot;%s回消息说:%s&quot; %(str(recv_data[1]),recv_data[0].decode(&quot;gbk&quot;)))\n\n\ndef main():\n    #创建套接字\n    udp_scoket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n\n    #绑定信息\n    #绑定的是一个元组，里面存放ip信息和端口信息\n    udp_scoket.bind((&quot;&quot;,7788))\n    # 确定对方地址\n    dest_ip &#x3D; input(&quot;请输入对方的ip:&quot;)\n    dest_port &#x3D; input(&quot;请输入对方的port:&quot;)\n\n    #循环发送接收消息\n    while True:\n            #发送\n            send_msg(udp_scoket,dest_ip,dest_port)\n\n            #接受并显示\n            recv_msg(udp_scoket)\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n这里测试自己收发程序运行如下：可以看出是做到了自己收发消息了的，即在一个程序里，自己发送数据给自己自己接收数据并打印显示，当然也可以用两份程序分别演示一个发送数据，一个接收数据。具体看自己怎么理解和操作。\n\n\n\n\n\n\n\n\n\n下一次记录 tcp 的有关知识和实践\n", "slug": "python高级学习日志第二、三天之网络编程", "date": "2022-10-01 09:29:00", "categories_index": "Python", "tags_index": "Python网络编程", "author_index": "倪传方"}, {"id": "3ab3df2387b700f13887b79994864558", "title": "python高级学习日志第一天之网络编程", "content": "\n\npython 高级学习日志第一天之网络编程UDP 发送数据\n\n\n\n\n\n\n\n\n一个 Java 程序员，但是打算自学一下 python，所以把自己学到的东西记录在这里。也免得我自己忘记新学的，年纪大了真的很容易忘东西。\n哈哈，我喜欢边写程序边听歌\n\n\n\n\n\n\n\n\n\n中国人民真蒸汽\n\n\n这里直接记录的是我的实践内容\n首先是怎么利用简单的 udp 来发送数据？\n这里我用的编辑工具是&#x3D;&#x3D; Pycharm &#x3D;&#x3D;测试的工具是 &#x3D;&#x3D; 网络调试助手 &#x3D;&#x3D;其中网络调试助手有多种样式的，下对了能用的就 ok，我的就长这样子：利用 udp 进行简单的数据发送有四个步骤\n\n创建一个套接字\n从键盘读取你要发送的数据\n使用套接字发送你的数据\n关闭套接字\n\n那么在 python 中要用到套接字，就像 java 导包一样也需要导入其中的套接字使用模块，使用 Pycharm 会自动提示不劝导入，真滴是特别的方便了。\n接着在最后的位置给 python 设置一个启动器(main 方法)，类似，java 里的\npublic static void main(String[] args)&#123;&#125;\n\npython 里的写法是 main 方法：\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n\n在这个 main 函数缩进的位置上写上要执行的函数名就 ok按照刚刚说的流程走一遍：\n#引入套接字使用模块\nimport socket\n\n\n#自定义一个方法叫做main(),方法名随意\ndef main():\n    #1.创建一个套接字,叫做udp_socket,固定的创建写法\n    #其中SOCK_DGRAM是代表基于udp的套接字，无保障的\n    udp_socket&#x3D;socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    #2.从键盘读取输入数据,赋值给send_data变量\n    send_data &#x3D; input(&quot;请输入要发送的数据:&quot;)\n\n    #3.使用套接字发送数据\n    #udp_socket套接字已经创建,用其自带的方法即可以实现发送,并且把发送的数据编码，防止中文输入乱码\n    udp_socket.sendto(send_data.encode(&quot;gbk&quot;), (&quot;10.128.246.239&quot;, 6666))\n\n    #4.关闭套接字\n    udp_socket.close()\n\n\n#在main方法里执行main()函数\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\nok,这是一个简单的流程，其中 10.128.246.239 和 6666 分别是要接受数据方的 ip 地址和端口号，接收方也是一个 udp，只不过这个 udp 用来接收数据，在这里用网络调试助手来模拟接收数据的 udp 方。\n\n\n\n\n\n\n\n\n\n注意：套接字的 sendto 方法需要带两个参数，第一个是发送的数据，是 byte 类型的，第二个参数是一个元组，类似 java 里的数组，(ip 地址，端口号)，ip 地址是字符串类型的，端口号是整型的。\n接下来用网络调试助手模拟数据接收方，打开网络调试助手，如下新建一个 udp其中 ip 地址换成当前联网的 ip，window 下可以用 win+R，输入 cmd 开启命令模式输入 ipconfig 即可查看当前网络的 ip把这个 ip 地址输入到网络调试助手的设置区的本地 ip 位置，当然助手也能自动捕获，如图，用上这个就行然后设置一个端口号，自己设置就行了，大于 1024 小于 65535 就行，排除电脑上有程序在用这个端口以外。启动，最终如下图，这个时候通过代码里的参数配置，已经可以连接上这个接收器了，运行 python 程序点绿色按钮选择运行即可,运行如图：然后输入数据测试发送，输入后回车。这个时候回到网络调试助手可以看到：来自本机地址，因为是自己发给自己测试，这个端口发来的这个数据。\n这个时候开始想，能不能循环输入数据发送？答案是可以的，把发送数据执行的代码片作为循环体即可。然后可以简单地设置一下，当用户输入“exit”的时候，让用户结束发送。然后代码变成了这样，把从键盘获取数据到发送数据作为循环体。用 while True: 圈起来，也就是把循环体一段缩进，相当于 java 中的{}大括号。然后用 if 判断用户输入的是不是 exit 字符串，是的话，则跳出循环，直接执行关闭套接字操作，程序运行结束。\nimport socket\n\n\ndef main():\n    # 创建一个udp套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    while True:\n        # 从键盘获取数据\n        send_data &#x3D; input(&quot;请输入要发送的数据:&quot;)\n        # 如果输入的数据是exit。则推出程序\n        if send_data &#x3D;&#x3D; &quot;exit&quot;:\n            break\n        # 使用套接字发送数据\n        udp_socket.sendto(send_data.encode(&quot;gbk&quot;), (&quot;10.128.246.239&quot;, 6666))\n    # 关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n\n\n\n\n\n\n\n\n\n\n注意，if 里也用了缩进，就相当于 java 的{}\n运行程序:这个时候，可以循环发送数据。打开网络调试助手：它也循环收到了数据如果输入“exit”退出程序，结束发送。\n这里我们可能会注意到这个细节有两种端口，这个是因为代码运行了两次，每次运行都由操作系统随机分配端口，总而言之，一个应用程序需要运行，则需要一个端口，当然在代码里也可以绑定端口，套接字绑定端口的操作会在 udp 接收数据里记录。\n\n\n\n\n\n\n\n\n\n小白新学 python 之网络编程入门，大神勿喷下一次记录怎么利用 udp 接收数据？\n", "slug": "python高级学习日志第一天之网络编程", "date": "2022-09-30 14:22:00", "categories_index": "Python", "tags_index": "Python网络编程", "author_index": "倪传方"}, {"id": "cb1bde52f4b0429979650f547c40a9be", "title": "jvm学习笔记之类的加载、连接与初始化", "content": "\n\njvm学习笔记之类的加载、连接与初始化——2019-04-04类的加载、连接与初始化\n\n\n\n\n\n\n\n\n\n加载：查找并加载类的二进制数据\n连接\n验证：确保被加载类的正确性\n准备：为类的静态变量分配内存，并将其初始化为默认值\n解析：把类中的符号引用转换为直接引用\n\n\n初始化：为类的静态变量赋予正确的初始值\n\n如：Class test{     Public static int a&#x3D;1;}在test类在被加载时，静态变量a首先被分配内存，设置默认值a&#x3D;0接着在初始化过程中才被赋予正确的初始值a&#x3D;1\nJava程序对类的使用方式可分为两种\n\n\n\n\n\n\n\n\n\n主动使用被动使用\n所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们\n主动使用（七种） 创建类的实例（new一个类对象） 访问某个类或接口的静态变量，或者对该静态变量赋值（对静态变量取值赋值）助记符 getstatic  putstatic 调用类的静态方法  助记符 invokestatic 反射（如Class.forName(“com.test.Test”)） 初始化一个类的子类如：Class Parent{}Class Child extends Parent{}当子类被初始化时，同时也标记着父类的主动使用，父类也会被初始化 Java虚拟机启动时被标明为启动类的类（Java Test） JDK1.7开始提供的动态语言支持Java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化\n除了以上七种情况，其它使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化\n类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，大致上放在堆区，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构\n 加载.class文件的方式\n\n\n\n\n\n\n\n\n\n 从本地系统中直接加载（ide工作区重启加载项目即是如此） 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件（如JSP中java代码的编写，实际上是转化成了Servlet）\n（主动使用）测试代码一\npackage com.lagoon.jvm.classloder;\n\npublic class MyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyChild1.str);\n    &#125;\n&#125;\n\nclass MyParent1&#123;\n\n    public static String str&#x3D;&quot;hello world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent1 static block&quot;);\n    &#125;\n&#125;\n\nclass MyChild1 extends MyParent1&#123;\n    static &#123;\n        System.out.println(&quot;MyChild1 static block&quot;);\n    &#125;\n&#125;\n\n\n测试结果\n并没有输出MyChild1 static block这种情况称之为对MyParent1的一个主动使用，但是并没有对MyChild1进行主动使用所以并不会对MyChild1进行初始化，也就不会执行静态代码块\n测试代码二\npackage com.lagoon.jvm.classloder;\n\npublic class MyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyChild1.str2);\n    &#125;\n&#125;\n\nclass MyParent1&#123;\n\n    public static String str&#x3D;&quot;hello world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent1 static block&quot;);\n    &#125;\n&#125;\n\nclass MyChild1 extends MyParent1&#123;\n    public static String str2&#x3D;&quot;welcome...&quot;;\n    static &#123;\n        System.out.println(&quot;MyChild1 static block&quot;);\n    &#125;\n&#125;\n\n\n测试结果\n此时在MyChild1中定义了一个str2，并在main方法中调用的str2，是对MyChild类的一次主动使用，自然会初始化，自然也就会执行静态代码块，输出语句而对于为什么MyParent1也会输出语句？是因为主动使用里有一条出初始化一个类的子类，那么也就是这个父类也会被主动使用，进行一次初始化。父类会进行先行初始化\n测试总结：对于一个静态字段来说，只有直接定义了该字段的类才会被初始化当一个类在初始化时，要求其父类全部都已经初始化完毕这就是问什么输出语句有先后顺序\n有关jvm虚拟机vm设置指令\n-XX:+TraceClassLoading,用于追踪类的加载信息并打印出来\n -XX:+&lt;option&gt;，表示开启option选项\n -XX:-&lt;option&gt;，表示关闭option选项\n*-XX:&lt;option&gt;&#x3D;&lt;value&gt;，表示将option的值设置为value\n\n再新建一个测试类MyTest2\npackage com.lagoon.jvm.classloder;\n\npublic class MyTest2 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyParent2.str);\n    &#125;\n&#125;\nclass MyParent2&#123;\n    public static String str&#x3D;&quot;hello,world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent2 static block&quot;);\n    &#125;\n&#125;\n\n\n测试结果\n显而易见是在MyParent2里定义了静态字段，所以会对这个类进行初始化，运行静态代码块但是如果把\npublic static  String str&#x3D;&quot;hello,world&quot;;\n\n改成\npublic static final String str&#x3D;&quot;hello,world&quot;;\n\n加上关键字final运行结果如下\n产生这种差异的原因是\nfinal本身的作用在于str被定义以后不能再被改变，str成为常量，然而常量在编译阶段，会被直接存入到调用这个常量的方法所在类（MyTest2）的常量池中之后，MyTest2与MyParent2就没有任何的关系了\n因此本质上，调用类，也就是MyTest2，并没有直接引用到定义这个常量的类，也就是MyParent2，因此不会触发定义常量的类的初始化\n对MyTest2进行反编译后如下\n\n\n\n\n\n\n\n\n\n\n助记符：ldc表示将int，float或是String类型的常量值从常量池中推送至栈顶\n", "slug": "jvm学习笔记之类的加载、连接与初始化——2019-04-04", "date": "2021-07-09 11:39:11", "categories_index": "Java", "tags_index": "jvm", "author_index": "倪传方"}, {"id": "c0ef1bb9822760c44fd32eaf5be50c8a", "title": "redis发布和订阅演示", "content": "\n\nRedis第五期：redis发布和订阅演示\n\n\n\n\n\n\n\n\nreis的数据类型操作不再多说了，参考 redis命令中文手册\n\n\n\n\n\n\n\n\n\n演示redis的发布和订阅分别在命令行客户端和编程客户端演示\n\n\n\n\n\n\n\n\n\n1.命令行客户端演示首先开启redis服务不多说了这里模拟一个发布者，三个订阅者在redis src下开启四个命令行终端，进入命令行模式，如下图：选取第一台作为发布者，其它三台作为订阅者\n\n\n\n\n\n\n\n\n\n首先在后三台终端上输入SUBSCRIBE hello 命令（如果有密码得先auth 密码命令输入密码）表示让这三台终端订阅hello这个频道，（分别回车）如图\n\n\n\n\n\n\n\n\n\n接着在第一台电脑上发布消息使用publish+频道名+消息  命令回车\n结果如下（注意观察）\n三台终端同时跳出被发布的消息\n\n\n\n\n\n\n\n\n\n2.用jedis编程客户端来演示\n源码如下：同样要引入jedis节点jar包\n&lt;dependency&gt;\n      &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;\n      &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;\n      &lt;version&gt;2.9.0&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n\n消息订阅者角色\npackage com.lagoon;\n\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPubSub;\n\n&#x2F;**\n * redis消息订阅者\n *&#x2F;\npublic class RedisSubscriber extends JedisPubSub &#123;\n\n    &#x2F;&#x2F;当接收到消息后触发该方法\n\n    @Override\n    public void onMessage(String channel, String message) &#123;\n        super.onMessage(channel, message);\n        System.out.println(&quot;频道[&quot;+channel+&quot;]发布了一条消息[&quot;+message+&quot;]&quot;);\n    &#125;\n\n    &#x2F;&#x2F;main方法接收消息，开启监听状态\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;连接到jedis\n        Jedis jedis&#x3D;new Jedis(&quot;192.168.5.131&quot;,6379);\n        jedis.auth(&quot;123456&quot;);\n\n        RedisSubscriber redisSubscriber&#x3D;new RedisSubscriber();\n\n        &#x2F;&#x2F;从频道订阅消息\n        jedis.subscribe(redisSubscriber,&quot;channel&quot;);\n    &#125;\n&#125;\n\n\n消息发布者角色\npackage com.lagoon;\n\nimport redis.clients.jedis.Jedis;\n\n&#x2F;&#x2F;消息发布者\npublic class RedisPublisher &#123;\n\n    public static void main(String[] args) &#123;\n        Jedis jedis&#x3D;new Jedis(&quot;192.168.5.131&quot;,6379);\n        jedis.auth(&quot;123456&quot;);\n\n        &#x2F;&#x2F;发布消息\n        jedis.publish(&quot;channel&quot;,&quot;大家好&quot;);\n\n        jedis.close();\n    &#125;\n&#125;\n\n\n开始演示，首先，运行消息订阅者类里的main方法程序处于监听状态，表示在等待消息发布\n接着运行发布消息类main方法如下运行完以后切换到消息订阅者运行窗口会发现收到了已经发布的消息\n这里甚至可以对代码进行一些改动，比如手动输入消息发布，不演示了\n", "slug": "redis发布和订阅演示", "date": "2019-09-07 08:33:00", "categories_index": "Redis", "tags_index": "redis发布与订阅", "author_index": "倪传方"}, {"id": "bdf4805eb354b82978231d675189aaca", "title": "Redis持久化的两种实现方式", "content": "\n\nRedis第七期：redis持久化的两种实现方式\n\n\n\n\n\n\n\n\n首先，什么是持久化，什么是redis的持久化持久化可以理解为存储，就是将数据存储到一个不会丢失的地方，如果把数据放在内存中，电脑关闭或重启数据就会丢失，所以放在内存中的数据不是持久化的，而放在磁盘就算是一种持久化。\n\n\n\n\n\n\n\n\n\nRedis的数据存储在内存中，内存是瞬时的，如果linux宕机或重启，又或者Redis崩溃或重启，所有的内存数据都会丢失，为解决这个问题，Redis提供两种机制对数据进行持久化存储，便于发生故障后能迅速恢复数据。\n\n\n\n\n\n\n\n\n\nredis提供两种持久化方式\n\n\n\n\n\n\n\n\n\n1.RDB方式Redis Database（RDB），就是在指定的时间间隔内将内存中的数据集快照写入磁盘，数据恢复时将快照文件直接再读到内存。RDB方式的数据持久化，仅需在redis.conf文件中配置即可配置文件redis.conf中搜索 SNAPSHOTTING其中配置格式：save 900 1save 300 10save 60 10000示例表示在900秒内发生1次改变就保存数据，类似如此那么保存数据在哪dbfilename：设置RDB的文件名，默认文件名为dump.rdbdir：指定RDB和AOF文件的目录以上这些都可以自定义配置容易发现其实redis默认开启RDB持久化的通过查找该文件名可以证明通过查找可以发现存在该文件，说明之前的操作都是RDB持久化了的，并在这个文件里被记录\n\n\n\n\n\n\n\n\n\nRDB持久化方式的优缺点优点：由于存储的是数据快照文件，恢复数据很方便，也比较快缺点：会丢失最后一次快照以后更改的数据\n\n\n\n\n\n\n\n\n\n如果你的应用能容忍一定数据的丢失，那么使用rdb是不错的选择如果你不能容忍一定数据的丢失，使用rdb就不是一个很好的选择\n\n\n\n\n\n\n\n\n\n由于需要经常操作磁盘，RDB 会经常 fork 出一个子进程。如果你的redis数据库很大的话，Fork 占用比较多的时间，并且可能会影响 Redis 暂停服务一段时间（millisecond 级别），如果你的数据库超级大并且你的服务器CPU比较弱，有可能是会达到一秒。\n\n\n\n\n\n\n\n\n\n2.第二种持久化方式AOF方式什么是AOF方式Append-only File（AOF），Redis每次接收到一条改变数据的命令时，它将把该命令写到一个AOF文件中（只记录写操作，读操作不记录），当Redis重启时，它通过执行AOF文件中所有的命令来恢复数据。AOF方式的数据持久化，仅需在redis.conf文件中配置即可在redis.conf配置文件中搜索APPEND ONLY MODE&gt;把appendonly 改为yes保存开启AOF持久化redis服务指定新配置开启先杀死服务进程以新配置开启redis服务&gt;在命令行终端写一些测试命令&gt;退出回到src目录下查找aof文件可以看见生成了持久化记录文件打开查看内容可见记录文件选择0号库，flushall清空所有，接着set k1 v1 ,set k2 v2aof文件只会记录写操作，不会记录读操作\n\n\n\n\n\n\n\n\n\n关于一些其配置appendfilename：指定AOF文件名，默认文件名为appendonly.aofappendfsync：配置向aof文件写命令数据的策略auto-aof-rewrite-percentage：当目前aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写，则以启动时的aof文件大小为依据auto-aof-rewrite-min-size：允许重写的最小AOF文件大小\n\n\n\n\n\n\n\n\n\n其中执行策略有no：不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），比较快但不是很安全always：每次执行写入都会执行同步，慢一些但是比较安全everysec：每秒执行一次同步操作，比较平衡，介于速度和安全之间\n\n\n\n\n\n\n\n\n\n总结append-only 文件是另一个可以提供完全数据保障的方案；AOF 文件会在操作过程中变得越来越大。比如，如果你做一百次加法计算，最后你只会在数据库里面得到最终的数值，但是在你的 AOF 里面会存在 100 次记录，其中 99 条记录对最终的结果是无用的；但 Redis 支持在不影响服务的前提下在后台重构 AOF 文件，让文件得以整理变小；可以同时使用这两种方式，redis默认优先加载aof文件；\n", "slug": "redis持久化的两种实现方式", "date": "2019-03-30 16:33:00", "categories_index": "Redis", "tags_index": "持久化", "author_index": "倪传方"}, {"id": "8539baf449cb37333713337188dfc881", "title": "redis对事务控制的实现", "content": "\n\nRedis第六期：redis对事务控制的实现\n\n\n\n\n\n\n\n\n首先，什么是事务？事务是指一系列操作步骤，这一系列的操作步骤，要么完全地执行，要么完全地不执行。比如微博中：A用户关注了B用户，那么A的关注人列表里面就会有B用户，B的粉丝列表里面就会有A用户。这个关注与被关注的过程是由一系列操作步骤构成：（1）A用户添加到B的粉丝列表里面（2）B用户添加到A的关注列表里面；这两个步骤必须全部执行成功，整个逻辑才是正确的，否则就会产生数据的错误，比如A用户的关注列表有B用户，但B的粉丝列表里没有A用户；要保证一系列的操作都完全成功，提出了事务控制的概念。\n\n\n\n\n\n\n\n\n\nredis事务Redis中的事务（transaction）是一组命令的集合，至少是两个或两个以上的命令，redis事务保证这些命令被执行时中间不会被任何其他操作打断。\nredis对事务控制的实现大致有以下几种情况：\n\n\n\n\n\n\n\n\n\n一，正常情况（测试中为避免冲突先flushall清空所有keys）1.用MULTI命令告诉Redis，接下来要执行的命令你先不要执行，而是把它们暂时存起来 （开启事务）开启事务，等待命令进入队列2.输入执行命令，进入命令队列queued返回值表示命令进入执行队列（注意此时还未执行）3.输入exec命令告知redis执行前面发送的命令（提交事务）可以看到exec后命令执行成功并且能够查询到相关值\n\n\n\n\n\n\n\n\n\n二，异常情况1.开启事务2.输入一个正常命令成功进入队列等待执行3.输入一个错误命令首先返回语法错误4.最后提交事务查看提交事务失败\n\n\n\n\n\n\n\n\n\n三，例外情况1.开启事务2.输入一个正常命令3.输入一个正常命令（本身没有语法错误）成功进入执行等待队列4.提交事务提示第一个命令执行成功第二个命令执行出错事务依然提交了，k5的值被设置为v5，自增操作执行失败，但整个事务没有回滚.\n\n\n\n\n\n\n\n\n\n四，放弃情况1.开启事务2.输入两个正常命令进入执行队列3.放弃事务放弃事务后，k6，k7并没有被赋值放弃事务，则命令队列不会被执行\n\n\n\n\n\n\n\n\n\n五，复杂情况这里要提到悲观锁和乐观锁概念\n\n\n\n\n\n\n\n\n\n悲观锁悲观锁(Pessimistic Lock)， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改该数据，所以每次在拿数据的时候都会先上锁，这样别人想拿这个数据就会block阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，让别人无法操作该数据。\n\n\n\n\n\n\n\n\n\n乐观锁乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改该数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这条数据，一般使用版本号机制进行判断。乐观锁适用于多读的应用类型，这样可以提高吞吐量。\n\n\n\n\n\n\n\n\n\n乐观锁大多数情况是基于数据版本号（version）的机制实现的。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个“version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据，不予更新。\n\n\n\n\n\n\n\n\n\n图例：\n\n\n\n\n\n\n\n\n\nredis的watch机制实现乐观锁监视一个(或多个) key ，如果在事务exec执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断这里开启两个终端来演示1.执行一个正常命令2.开启对money的监控3.开启事务4.在事务等待命令的这段时间里，在另一个终端里改变money值（注意回车）5.接着在第一个终端里事务改写money值6.提交事务查看事务提交不了，因为发现在事务等待过程中，money值被监控已经发小被修改了，所以无法提交事务7.查看money值发现值最终是另一个终端改动影响的\n", "slug": "redis对事务控制的实现", "date": "2019-03-25 19:26:00", "categories_index": "Redis", "tags_index": "事务控制", "author_index": "倪传方"}, {"id": "4ab18f90b2937be74536568e1919dbe5", "title": "Redis的一个小坑", "content": "\n\nRedis 的一个小坑\n\n\n\n\n\n\n\n\n又忘了，修改了 redis 的配置文件就一定要重新制定配置文件启动太坑了，记录一下测试成功\npackage com.lagoon;\n\nimport redis.clients.jedis.Jedis;\n\n&#x2F;**\n * Hello world!\n *\n *&#x2F;\npublic class App\n&#123;\n    public static void main( String[] args )\n    &#123;\n        &#x2F;&#x2F;根据端口和ip连接redis\n        Jedis jedis&#x3D;new Jedis(&quot;192.168.5.128&quot;,6379);\n        &#x2F;&#x2F;输入密码\n        jedis.auth(&quot;123456&quot;);\n        System.out.println(&quot;服务正在运行&quot;+jedis.ping());\n    &#125;\n&#125;\n\n\n\n", "slug": "Redis的一个小坑", "date": "2019-03-23 22:23:00", "categories_index": "Redis", "tags_index": "tips", "author_index": "倪传方"}, {"id": "c1b8e397764a04b15b42b94eec3a8f01", "title": "有关Docker容器架构", "content": "\n\n有关Docker容器架构\n\n\n\n\n\n\n\n\n\nDocker客户端与服务器Docker是一个客户端-服务器的（C&#x2F;S）架构程序，Docker的客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具和一整套RESTful API。你可以在同一台主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。\n\n\n\n\n\n\n\n\n\nDocker镜像镜像（Image）是Docker中的一个模板。通过Docker镜像来创建Docker容器，一个镜像可以创造出多个容器。镜像是由一系列指令一步一步构建出来，例如：\n\n添加一个文件\n执行一个命令\n打开一个窗口\n\n\n\n\n\n\n\n\n\n\nj镜像与容器的关系类似于java中类与对象的关系镜像体积很小，非常“便携”，易于分享，存储和更新。\n\n\n\nDocker\nJava\n\n\n\n镜像\n类\n\n\n容器\n对象\n\n\nclass Emp&#123;&#125; &#x2F;&#x2F;镜像：\nEmp e1 &#x3D; new Emp(); &#x2F;&#x2F;容器1\nEmp e2 &#x3D; new Emp(); &#x2F;&#x2F;容器2\n\n\n\n\n\n\n\n\n\n\nDocker容器容器（Container）是基于镜像创建的运行的实例，一个容器中可以运行一个或者多个应用程序（jdk+开发的java应用程序）。Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。可以认为，镜像是Docker生命周期的构建或者打包阶段，而容器则是启动或者执行阶段。可以理解容器中有包含：一个精简版的Linux环境+要运行的应用程序\n\n\n\n\n\n\n\n\n\nDocker仓库仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库（Repository）和仓库注册服务器（Registry）混为一谈，但并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。仓库分为公有仓库（Public）和私有仓库（Private）两种。Docker公司运营的公共仓库叫做 Docker Hub （https://hub.docker.com/），存放了数量庞大的镜像供用户下载。用户可以在Docker Hub注册账号，分享并保存自己的镜像。（说明：在Docker Hub下载镜像巨慢）国内的公有仓库包括阿里云 、网易云 等，可以提供大陆用户更稳定快速的访问。当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。\n\n", "slug": "有关Docker容器架构", "date": "2019-03-22 10:29:00", "categories_index": "Devops", "tags_index": "Docker", "author_index": "倪传方"}]