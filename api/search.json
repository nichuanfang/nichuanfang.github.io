[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n1. 快速开始创建新文档hexo new &quot;My New Post&quot;\n\nMore info: Writing\n启动本地服务hexo server\n\nMore info: Server\n构建静态文件hexo generate\n\nMore info: Generating\n部署hexo deploy\n\nMore info: Deployment\n2. Markdown自定义容器所有的自定义容器都使用这种格式:\n:::[type] [title]\n文本内容\n:::\n\n\ntype 是容器的类型\ntitle 是可选的,可以用来重命名容器的标题\n\nTip容器:::tip\nNormal Tips Container\n:::\n\n\n如果你不想使用默认的标题TIP，你可以使用以下方法重命名你的容器标题:\n:::tip Custom header\n\nCustom header\n\n- tips content\n- tips new line\n\n:::\n\n\nWarning 容器:::warning\nWarning!!!\n:::\n\n\nDanger 容器:::danger\nDanger!!!\n:::\n\n\nDetails 容器这是一种特殊类型的容器。如果你看过 GitHub 中的 details 容器，你可能会猜出它的功能是什么。\n是的，您可以隐藏某些内容，并单击来展开它。\n:::details Click to see more\n\nFusce rutrum venenatis eros in hendrerit. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nullam eget risus egestas, aliquet ipsum sed, volutpat tortor. Proin finibus tortor ac mauris finibus rutrum. Nullam tincidunt arcu eu urna ullamcorper, eu ultricies turpis ornare. Morbi id sollicitudin orci. Proin lobortis vehicula nibh a ornare. Cras sodales eu ligula quis fermentum. Proin eu ultrices leo, quis iaculis justo. Sed dictum, nulla sit amet imperdiet commodo, libero sapien semper justo, ut lobortis elit nunc vitae ante. Nullam lobortis odio quam, ac condimentum elit posuere vitae. Sed ornare, odio et rutrum varius, lorem eros gravida urna, in pharetra sapien justo non magna.\n\n- details content\n- details new line\n\n&#96;console.log(&#39;hello world&#39;)&#96;\n\n:::\n\n\n关闭状态:\n\n展开状态:\n\n","slug":"hello-world","date":"2023-05-11T00:19:00.000Z","categories_index":"文章模板","tags_index":"template","author_index":"倪传方"},{"id":"1269f6284fcda69dd94df081174c6509","title":"个人简历","content":"欢迎使用在线 Vditor Markdown 编辑器vditor 是一款浏览器端的 Markdown 编辑器，支持所见即所得、即时渲染（类似 Typora）和分屏预览模式。它使用 TypeScript 实现，支持原生 JavaScript、Vue、React 和 Angular。您可以使用Vditor Markdown：\n\n\n\n\n\n\n\n\n\n\n整理知识，学习笔记\n发布日记，杂文，所见所想\n撰写发布技术文稿（代码支持）\n撰写发布学术论文（LaTeX 公式支持）\n\n如何使用微注：清空目前这份默认文档，即处于可使用态。vditor 另一大优点在于：编辑内容只会在您本地进行保存，不会上传您的数据至服务器，绝不窥测用户个人隐私，可放心使用；Github 源码：markdown-online-editor，部分功能仍在开发🚧，敬请期待。\n默认为所见即所得模式，可通过 ⌘-⇧-M（Ctrl-⇧-M）进行切换；或通过以下方式：\n\n所见即所得：⌘-⌥-7（Ctrl-alt-7）；\n即时渲染：⌘-⌥-8（Ctrl-alt-8）；\n分屏渲染：⌘-⌥-9（Ctrl-alt-9）；\n\nPPT 预览如果您用作 PPT 预览（入口在 设置中），需要注意，这里暂还不能支持各种图表的渲染；您可以使用 --- 来定义水平方向上幻灯片，用 -- 来定义垂直幻灯片；更多设定可以参见 RevealJs 文档。\n\n什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号，以最小的输入代价，生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体、斜体 或者超文本链接，更棒的是，它还可以：\n\n1. 制作待办事宜 Todo 列表\n 🎉 通常Markdown 解析器自带的基本功能；\n 🍀 支持流程图、甘特图、时序图、任务列表；\n 🏁 支持粘贴 HTML 自动转换为 Markdown；\n 💃🏻 支持插入原生 Emoji、设置常用表情列表；\n 🚑 支持编辑内容保存本地存储，防止意外丢失；\n 📝 支持实时预览，主窗口大小拖拽，字符计数；\n 🛠 支持常用快捷键(Tab)，及代码块添加复制\n ✨ 支持导出携带样式的 PDF、PNG、JPEG 等；\n ✨ 升级 Vditor，新增对echarts 图表的支持；\n 👏 支持检查并格式化 Markdown 语法，使其专业；\n 🦑 支持五线谱、及部分站点、视频、音频解析；\n 🌟 增加对所见即所得编辑模式的支持(⌘-⇧-M)；\n\n\n2. 书写一个质能守恒公式[^LaTeX]$$E&#x3D;mc^2$$\n\n3. 高亮一段代码[^code]&#x2F;&#x2F; 给页面里所有的 DOM 元素添加一个 1px 的描边（outline）;\n[].forEach.call($$(&quot;*&quot;),function(a)&#123;\n  a.style.outline&#x3D;&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16);\n&#125;)\n\n4. 高效绘制流程图graph TD;\n  A--&gt;B;\n  A--&gt;C;\n  B--&gt;D;\n  C--&gt;D;\n\n5. 高效绘制序列图sequenceDiagram\n  participant Alice\n  participant Bob\n  Alice-&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts &lt;br&#x2F;&gt;prevail...\n  John--&gt;Alice: Great!\n  John-&gt;Bob: How about you?\n  Bob--&gt;John: Jolly good!\n\n6. 高效绘制甘特图\n\n\n\n\n\n\n\n\n甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。\ngantt\n  title 项目开发流程\n  section 项目确定\n    需求分析       :a1, 2019-06-22, 3d\n    可行性报告     :after a1, 5d\n    概念验证       : 5d\n  section 项目实施\n    概要设计      :2019-07-05  , 5d\n    详细设计      :2019-07-08, 10d\n    编码          :2019-07-15, 10d\n    测试          :2019-07-22, 5d\n  section 发布验收\n    发布: 2d\n    验收: 3d\n\n7. 支持图表&#123;\n  &quot;backgroundColor&quot;: &quot;#212121&quot;,\n  &quot;title&quot;: &#123;\n    &quot;text&quot;: &quot;「云生博客」访问来源&quot;,\n    &quot;subtext&quot;: &quot;2020 年 6 月份&quot;,\n    &quot;x&quot;: &quot;center&quot;,\n    &quot;textStyle&quot;: &#123;\n      &quot;color&quot;: &quot;#f2f2f2&quot;\n    &#125;\n  &#125;,\n  &quot;tooltip&quot;: &#123;\n    &quot;trigger&quot;: &quot;item&quot;,\n    &quot;formatter&quot;: &quot;&#123;a&#125; &lt;br&#x2F;&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot;\n  &#125;,\n  &quot;legend&quot;: &#123;\n    &quot;orient&quot;: &quot;vertical&quot;,\n    &quot;left&quot;: &quot;left&quot;,\n    &quot;data&quot;: [\n      &quot;搜索引擎&quot;,\n      &quot;直接访问&quot;,\n      &quot;推荐&quot;,\n      &quot;其他&quot;,\n      &quot;社交平台&quot;\n    ],\n    &quot;textStyle&quot;: &#123;\n      &quot;color&quot;: &quot;#f2f2f2&quot;\n    &#125;\n  &#125;,\n  &quot;series&quot;: [\n    &#123;\n      &quot;name&quot;: &quot;访问来源&quot;,\n      &quot;type&quot;: &quot;pie&quot;,\n      &quot;radius&quot;: &quot;55%&quot;,\n      &quot;center&quot;: [\n        &quot;50%&quot;,\n        &quot;60%&quot;\n      ],\n      &quot;data&quot;: [\n        &#123;\n          &quot;value&quot;: 10440,\n          &quot;name&quot;: &quot;搜索引擎&quot;,\n          &quot;itemStyle&quot;: &#123;\n            &quot;color&quot;: &quot;#ef4136&quot;\n          &#125;\n        &#125;,\n        &#123;\n          &quot;value&quot;: 4770,\n          &quot;name&quot;: &quot;直接访问&quot;\n        &#125;,\n        &#123;\n          &quot;value&quot;: 2430,\n          &quot;name&quot;: &quot;推荐&quot;\n        &#125;,\n        &#123;\n          &quot;value&quot;: 342,\n          &quot;name&quot;: &quot;其他&quot;\n        &#125;,\n        &#123;\n          &quot;value&quot;: 18,\n          &quot;name&quot;: &quot;社交平台&quot;\n        &#125;\n      ],\n      &quot;itemStyle&quot;: &#123;\n        &quot;emphasis&quot;: &#123;\n          &quot;shadowBlur&quot;: 10,\n          &quot;shadowOffsetX&quot;: 0,\n          &quot;shadowColor&quot;: &quot;rgba(0, 0, 0, 0.5)&quot;\n        &#125;\n      &#125;\n    &#125;\n  ]\n&#125;\n\n\n\n\n\n\n\n\n\n\n备注：上述 echarts 图表📈，其数据，须使用严格的 JSON 格式；您可使用 JSON.stringify(data)，将对象传换从而得标准数据，即可正常使用。\n8. 绘制表格\n\n\n作品名称\n在线地址\n上线日期\n\n\n\n云生博客\nhttps://www.qikaile.tk\n2020-03-14\n\n\n网站监控\nhttps://tjys.now.sh\n2020-05-16\n\n\n云生网盘\nhttps://tjys.cf\n2021-05-16\n\n\n9. 更详细语法说明想要查看更详细的语法说明，可以参考这份 Markdown 资源列表，涵盖入门至进阶教程，以及资源、平台等信息，能让您对她有更深的认知。\n总而言之，不同于其它所见即所得的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式，而且越发流行，正在在向各行业渗透。\n最新更新于 2019.08.21\n","slug":"resume","date":"2023-05-09T23:18:05.000Z","categories_index":"简历","tags_index":"resume","author_index":"倪传方"},{"id":"2e5004b8a8ff49317aa7f3e9b71f74cf","title":"可重入锁ReentrantLock高级特性","content":"ReentrantLock提供了Synchronized不具备的三个高级特性\n公平锁\n\n&#x2F;**\n * Creates an instance of &#123;@code ReentrantLock&#125;.\n * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.\n *&#x2F;\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync(); \n&#125;\n\n\n等待可中断\n\n&#x2F;**\n * 尝试锁定\n *\n * @param timeout 超时时间\n * @param unit    单位\n * @return boolean 尝试获取锁的结果\n * @throws InterruptedException 中断异常\n *&#x2F;\npublic boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n&#125;\n\n\n\n\n\n\n\n提示\n条件通知,一把锁可以生成多个条件,每个条件可以对应一个线程分组,可以通过condition对象来进行分组等待和唤醒,解决了synchronized关键字只能notifyAll()的问题\n\npublic Condition newCondition() &#123;\n    return sync.newCondition();\n&#125;\n\n\n\n\n\n\n\n\n注意\nReentrantLock条件通知使用注意点\n\n\n每个condition可以绑定若干个线程,如果需要多个condition请先对线程进行分组;\n使用await()和signal()或者signalAll()之前需要先获取锁,在finally代码块中要释放锁;\n\n实战演示模拟三个线程,对其中两个线程分为一组绑定到condition1,剩下的一个线程单独一组绑定到condition2,main线程再分别唤醒等待状态的各线程组.\n\n创建线程池\n\nprivate final ThreadFactory threadFactory &#x3D; ThreadFactoryBuilder.create().setNamePrefix(&quot;test&quot;).build();\n\nprivate final Executor executor &#x3D; new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() + 1, Runtime.getRuntime().availableProcessors() + 1,\n        10, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(16), threadFactory, new ThreadPoolExecutor.AbortPolicy());\n\n\n初始化CountDownLatch和ReentrantLock,注册两个condition.\n\n&#x2F;&#x2F;闭锁1  让3个子线程同时启动\nCountDownLatch startCdl &#x3D; new CountDownLatch(1);\n&#x2F;&#x2F;闭锁2  main线程等待子线程都执行完毕再结束\nCountDownLatch endCdl &#x3D; new CountDownLatch(3);\n&#x2F;&#x2F;同步锁\nReentrantLock lock &#x3D; new ReentrantLock(false);\n\nCondition condition1 &#x3D; lock.newCondition();\nCondition condition2 &#x3D; lock.newCondition();\n\n\n创建子线程,进入等待状态,等主线程唤醒\n\n&#x2F;**\n * 获取线程\n *\n * @param startCdl       开始同步器\n * @param endCdl         结束同步器\n * @param lock      锁\n * @param condition 条件\n * @return &#123;@link Thread&#125;\n *&#x2F;\nprivate Runnable getCallable(CountDownLatch startCdl, CountDownLatch endCdl, ReentrantLock lock, Condition condition) &#123;\n    return () -&gt; &#123;\n        try &#123;\n            &#x2F;&#x2F;让三个子线程同时启动\n            startCdl.await();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        lock.lock();\n        try &#123;\n            &#x2F;&#x2F;await会释放当前锁\n            condition.await();\n            log.info(&quot;线程&#123;&#125;被唤醒,时间:&#123;&#125;&quot;, Thread.currentThread().getName(),new Date());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            log.info(&quot;线程:&#123;&#125;执行完毕,释放同步锁&quot;,Thread.currentThread().getName());\n            &#x2F;&#x2F;被唤醒后,需要释放当前持有的锁\n            lock.unlock();\n            &#x2F;&#x2F;计数器为0主线程停止等待\n            endCdl.countDown();\n        &#125;\n    &#125;;\n&#125;\n&#x2F;&#x2F;启动三个子线程\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl,lock, condition2));\n\n\n主线程进行唤醒\n\nlog.info(&quot;Main线程开始执行....&quot;);\nstartCdl.countDown();\nlog.info(&quot;子线程正在等待....&quot;);\n\nlock.lock();\ncondition1.signalAll();\nlock.unlock();\ntry &#123;\n    &#x2F;&#x2F;主线程阻塞2秒 区分两次唤醒\n    Thread.sleep(2000);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\nlock.lock();\ncondition2.signal();\nlock.unlock();\ntry &#123;\n    log.info(&quot;等待三个子线程执行完毕&quot;);\n    endCdl.await();\n    log.info(&quot;main线程结束&quot;);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\n\n\n控制台输出. 可以看出两次唤醒相隔了两秒\n\n","slug":"reentrant-lock","date":"2023-05-07T23:05:39.000Z","categories_index":"可重入锁","tags_index":"ReentrantLock","author_index":"倪传方"},{"id":"c303ed11a2ccec4894d7653bfc906c12","title":"hahah","content":"发表一篇测试文章","slug":"hahah","date":"2023-05-12T15:39:03.000Z","categories_index":"测试文章","tags_index":"test","author_index":"倪传方"}]