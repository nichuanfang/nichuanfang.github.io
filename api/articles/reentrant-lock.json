{"title": "可重入锁ReentrantLock高级特性", "uid": "2e5004b8a8ff49317aa7f3e9b71f74cf", "slug": "reentrant-lock", "date": "2023-05-08 07:05:39", "updated": "2023-07-26 17:54:45.005000", "comments": true, "path": "api/articles/reentrant-lock.json", "keywords": null, "cover": "/img/reentrant-lock/reentrant-lock.jpg", "content": "<h2 id=\"ReentrantLock提供了Synchronized不具备的三个高级特性\"><a href=\"#ReentrantLock提供了Synchronized不具备的三个高级特性\" class=\"headerlink\" title=\"ReentrantLock提供了Synchronized不具备的三个高级特性\"></a><code>ReentrantLock</code>提供了<code>Synchronized</code>不具备的三个高级特性</h2><ul>\n<li>公平锁</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Creates an instance of &#123;@code ReentrantLock&#125;.\n * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.\n *&#x2F;\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync();\n&#125;</code></pre>\n\n<ul>\n<li>等待可中断</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 尝试锁定\n *\n * @param timeout 超时时间\n * @param unit    单位\n * @return boolean 尝试获取锁的结果\n * @throws InterruptedException 中断异常\n *&#x2F;\npublic boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n&#125;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>条件通知,一把锁可以生成多个条件,每个条件可以对应一个线程分组,可以通过 condition 对象来进行分组等待和唤醒,解决了<code>synchronized</code>关键字只能<code>notifyAll()</code>的问题</p>\n</div>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Condition newCondition() &#123;\n    return sync.newCondition();\n&#125;</code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><code>ReentrantLock</code>条件通知使用注意点</p>\n</div>\n<ul>\n<li>每个 condition 可以绑定若干个线程,如果需要多个 condition 请先对线程进行分组;</li>\n<li>使用<code>await()</code>和<code>signal()</code>或者<code>signalAll()</code>之前需要先获取锁,在 finally 代码块中要释放锁;</li>\n</ul>\n<h2 id=\"实战演示\"><a href=\"#实战演示\" class=\"headerlink\" title=\"实战演示\"></a>实战演示</h2><p>模拟三个线程,对其中两个线程分为一组绑定到<code>condition1</code>,剩下的一个线程单独一组绑定到<code>condition2</code>,main 线程再分别唤醒等待状态的各线程组.</p>\n<ul>\n<li>创建线程池</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final ThreadFactory threadFactory &#x3D; ThreadFactoryBuilder.create().setNamePrefix(&quot;test&quot;).build();\n\nprivate final Executor executor &#x3D; new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() + 1, Runtime.getRuntime().availableProcessors() + 1,\n        10, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(16), threadFactory, new ThreadPoolExecutor.AbortPolicy());</code></pre>\n\n<ul>\n<li>初始化<code>CountDownLatch</code>和<code>ReentrantLock</code>,注册两个<code>condition</code>.</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;闭锁1  让3个子线程同时启动\nCountDownLatch startCdl &#x3D; new CountDownLatch(1);\n&#x2F;&#x2F;闭锁2  main线程等待子线程都执行完毕再结束\nCountDownLatch endCdl &#x3D; new CountDownLatch(3);\n&#x2F;&#x2F;同步锁\nReentrantLock lock &#x3D; new ReentrantLock(false);\n\nCondition condition1 &#x3D; lock.newCondition();\nCondition condition2 &#x3D; lock.newCondition();</code></pre>\n\n<ul>\n<li>创建子线程,进入等待状态,等主线程唤醒</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 获取线程\n *\n * @param startCdl       开始同步器\n * @param endCdl         结束同步器\n * @param lock      锁\n * @param condition 条件\n * @return &#123;@link Thread&#125;\n *&#x2F;\nprivate Runnable getCallable(CountDownLatch startCdl, CountDownLatch endCdl, ReentrantLock lock, Condition condition) &#123;\n    return () -&gt; &#123;\n        try &#123;\n            &#x2F;&#x2F;让三个子线程同时启动\n            startCdl.await();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        lock.lock();\n        try &#123;\n            &#x2F;&#x2F;await会释放当前锁\n            condition.await();\n            log.info(&quot;线程&#123;&#125;被唤醒,时间:&#123;&#125;&quot;, Thread.currentThread().getName(),new Date());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            log.info(&quot;线程:&#123;&#125;执行完毕,释放同步锁&quot;,Thread.currentThread().getName());\n            &#x2F;&#x2F;被唤醒后,需要释放当前持有的锁\n            lock.unlock();\n            &#x2F;&#x2F;计数器为0主线程停止等待\n            endCdl.countDown();\n        &#125;\n    &#125;;\n&#125;\n&#x2F;&#x2F;启动三个子线程\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl,lock, condition2));</code></pre>\n\n<ul>\n<li>主线程进行唤醒</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">log.info(&quot;Main线程开始执行....&quot;);\nstartCdl.countDown();\nlog.info(&quot;子线程正在等待....&quot;);\n\nlock.lock();\ncondition1.signalAll();\nlock.unlock();\ntry &#123;\n    &#x2F;&#x2F;主线程阻塞2秒 区分两次唤醒\n    Thread.sleep(2000);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\nlock.lock();\ncondition2.signal();\nlock.unlock();\ntry &#123;\n    log.info(&quot;等待三个子线程执行完毕&quot;);\n    endCdl.await();\n    log.info(&quot;main线程结束&quot;);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;</code></pre>\n\n<ul>\n<li>控制台输出. 可以看出两次唤醒相隔了两秒<br><img src=\"/img/reentrant-lock/reentrant-lock-test.webp\" alt=\"alt\"></li>\n</ul>\n", "text": "ReentrantLock提供了Synchronized不具备的三个高级特性 公平锁 &#x2F;** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using ...", "link": "", "photos": [], "count_time": {"symbolsCount": "3.7k", "symbolsTime": "3 mins."}, "categories": [{"name": "分布式", "slug": "分布式", "count": 1, "path": "api/categories/分布式.json"}], "tags": [{"name": "ReentrantLock", "slug": "ReentrantLock", "count": 1, "path": "api/tags/ReentrantLock.json"}], "toc": "<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReentrantLock%E6%8F%90%E4%BE%9B%E4%BA%86Synchronized%E4%B8%8D%E5%85%B7%E5%A4%87%E7%9A%84%E4%B8%89%E4%B8%AA%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">ReentrantLock提供了Synchronized不具备的三个高级特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%98%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">实战演示</span></a></li></ol>", "author": {"name": "倪传方", "slug": "blog-author", "avatar": "/img/site/avatar.webp", "link": "/", "description": "一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>", "socials": {"github": "https://github.com/nichuanfang", "twitter": "https://twitter.com/jayzhouzj", "stackoverflow": "https://stackoverflow.com/users/12083298/jaychou", "wechat": "", "qq": "", "weibo": "", "zhihu": "https://www.zhihu.com/people/ba-dao-yi-shan-zhu", "csdn": "https://blog.csdn.net/Saphroth", "juejin": "https://juejin.cn/user/2740456686366830", "customs": {}}}, "mapped": true, "prev_post": {"title": "个人简历", "uid": "1269f6284fcda69dd94df081174c6509", "slug": "resume", "date": "2023-05-10 07:18:05", "updated": "2023-07-26 17:54:45.005000", "comments": true, "path": "api/articles/resume.json", "keywords": null, "cover": "/img/resume/resume.jpg", "feature": true, "text": "个人信息 倪传方&#x2F;男&#x2F;1994.08 本科&#x2F;合肥工业大学-工程力学 工作年限: 4 年 工作单位: 鸿程计算机系统有限公司-至今 Github: https://github.com/nichuanfang Gitee: https://gitee....", "link": "", "photos": [], "count_time": {"symbolsCount": "2.2k", "symbolsTime": "2 mins."}, "categories": [{"name": "作品集", "slug": "作品集", "count": 1, "path": "api/categories/作品集.json"}], "tags": [{"name": "resume", "slug": "resume", "count": 1, "path": "api/tags/resume.json"}], "author": {"name": "倪传方", "slug": "blog-author", "avatar": "/img/site/avatar.webp", "link": "/", "description": "一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>", "socials": {"github": "https://github.com/nichuanfang", "twitter": "https://twitter.com/jayzhouzj", "stackoverflow": "https://stackoverflow.com/users/12083298/jaychou", "wechat": "", "qq": "", "weibo": "", "zhihu": "https://www.zhihu.com/people/ba-dao-yi-shan-zhu", "csdn": "https://blog.csdn.net/Saphroth", "juejin": "https://juejin.cn/user/2740456686366830", "customs": {}}}, "mapped": true}, "next_post": {"title": "python高级学习日志第二、三天之网络编程", "uid": "e266b70dd1da3efc040f3fd65a612a8c", "slug": "python高级学习日志第二、三天之网络编程", "date": "2022-10-01 09:29:00", "updated": "2023-07-26 17:54:45.005000", "comments": true, "path": "api/articles/python高级学习日志第二、三天之网络编程.json", "keywords": null, "cover": "/img/python高级学习日志第二、三天之网络编程/python高级学习日志第二、三天之网络编程.jpg", "content": "<meta name=\"referrer\" content=\"no-referrer\" />\n\n<h2 id=\"python-高级学习日志第二、三天之网络编程\"><a href=\"#python-高级学习日志第二、三天之网络编程\" class=\"headerlink\" title=\"python 高级学习日志第二、三天之网络编程\"></a>python 高级学习日志第二、三天之网络编程</h2><h3 id=\"UDP-接收数据以及基于-UDP-的交易聊天器\"><a href=\"#UDP-接收数据以及基于-UDP-的交易聊天器\" class=\"headerlink\" title=\"UDP 接收数据以及基于 UDP 的交易聊天器\"></a>UDP 接收数据以及基于 UDP 的交易聊天器</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一个 Java 程序员，但是打算自学一下 python，所以把自己学到的东西记录在这里。也免得我自己忘记新学的，年纪大了真的很容易忘东西。</p></blockquote>\n<p>哈哈，我喜欢边写程序边听歌</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=502839372&auto=0&height=66\"></iframe>\n\n<p>上次记录的是怎么用 udp 来发送数据，通过网络调试助手按钮来模拟数据接收方，这次记录的是利用 udp 代码来接收数据，以及基于两份 python 代码的简易聊天器。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>话不多说直接开搞</p></blockquote>\n<p>首先是单纯的用 udp 来接收数据，这里同样用网络调试助手来模拟发送数据，这个时候网络调试助手扮演的角色是发送数据方。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>利用 udp 接收数据有以下几个主要步骤：</p></blockquote>\n<ol>\n<li>创建套接字</li>\n<li>绑定本地信息，包括本地 ip 以及分配端口号</li>\n<li>接收数据</li>\n<li>打印接收到的数据</li>\n<li>关闭套接字</li>\n</ol>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.接收数据\n    recv_data &#x3D; udp_socket.recvfrom(1024)\n    # 4.打印接收到的数据\n    print(recv_data)\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在绑定本地信息过程中，套接字调用 bind()方法，其中绑定的内容是一个元组，(“,xxxx),元组的第一个值为本地 ip，不用些即可，代码运行时会自动填充，第二个是手动给这个接收的代码片运行分配一个端口号，可在 1024 至 65535 之间随意填写，除本机有程序已经在占用这个端口使用以外，这里我随机绑定的端口号是 7788，至于元组的第一个元素为什么带有引号，是因为他是一个字符串类型的参数。<br>绑定好本地信息以后准备接受来自其它 udp 发送来的数据<br>recv_data &#x3D; udp_socket.recvfrom(1024)<br>调用套接字的 recvfrom 方法，1024 是指最大接收的数据量，这里用 1Kb 测试，最后把接收到的数据存进变量<br>recv_data 里，然后运行程序：<br><img src=\"https://img-blog.csdnimg.cn/20190108142647212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>此时没有任何动作是因为程序正在等待接收数据<br>然后打开网络调试助手新建一个 udp 来模拟发送数据<br><img src=\"https://img-blog.csdnimg.cn/20190108142911501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>同样的把相关配置做好，1 号处填上本地的 ip 地址，2 好处给网络调试助手启动服务器分配一个端口，3 号处也是填上本地 ip 地址，因为是同一台电脑发送数据和接收数据，4 号处填上代码里绑定的端口号，也就是 python 代码运行分配的端口号，所以整个过程相当于启动网络调试助手的 udp 作为数据发送方，然后填好要发给的另一方的信息。启动调试助手：<br><img src=\"https://img-blog.csdnimg.cn/20190108143524867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>输入测试发送的信息点击发送：<br><img src=\"https://img-blog.csdnimg.cn/2019010814362627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>回到代码运行处查看：<br><img src=\"https://img-blog.csdnimg.cn/20190108143653739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以看到显示的是一个大元组，大元组的第一个袁术是接收到的数据，在这里是中文的 ASCII 码，时 byte 类型的数据，然后后面跟着一组小元组，小元组的内容显而易见，小元组的第一个元素是数据发送方的 ip，第二个元素是数据发送方的端口号。接下来对代码做一些改变：</p></blockquote>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.接收数据\n\n    recv_data &#x3D; udp_socket.recvfrom(1024)\n    # 解析元祖的消息内容\n    recv_msg &#x3D; recv_data[0]  # 存储接收到的数据\n    send_addr &#x3D; recv_data[1]  # 存储发送方的地址信息\n    # 4.打印接收到的数据\n    print(&quot;%s说:%s&quot; % (str(send_addr), recv_msg.decode(&quot;gbk&quot;)))\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>把原本的 recv_data 做一个拆分解析，把 recv_data 的第一个元素赋值给 recv_msg，表示收到的消息和数据。把 recv_data 的第二个元素赋值给 send_addr，是一个小元组，表示发送方的信息，其过程和 java 数组取值类似，最后分别做输出，需要注意的是，str 强转和接收到的数据转码。最后重新运行程序：<br><img src=\"https://img-blog.csdnimg.cn/20190108144956841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>等待收数据，然后在调试助手输入发送的数据：<br><img src=\"https://img-blog.csdnimg.cn/20190108145034234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>则代码最后运行结果如下：<br><img src=\"https://img-blog.csdnimg.cn/20190108145056413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>以上这种情况可以看出是收到一条数据则结束程序运行。<br>接下来对代码进行改进能让代码持续收到书：</p></blockquote>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\n\ndef main():\n    # 1.创建套接字\n    udp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # 2.绑定一个本地信息，分配端口号\n    localaddr &#x3D; (&quot;&quot;, 7788)\n    udp_socket.bind(localaddr)\n    # 3.循环接收数据\n    while True:\n        recv_data &#x3D; udp_socket.recvfrom(1024)\n        # 解析元祖的消息内容\n        recv_msg &#x3D; recv_data[0]  # 存储接收到的数据\n        send_addr &#x3D; recv_data[1]  # 存储发送方的地址信息\n        # 4.打印接收到的数据\n        print(&quot;%s说:%s&quot; % (str(send_addr), recv_msg.decode(&quot;gbk&quot;)))\n    # 5.关闭套接字\n    udp_socket.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以看出是将套接字收数据和打印数据作为循环体来循环，这个时候测试数据接收如下：<br><img src=\"https://img-blog.csdnimg.cn/20190108145507304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>在网络调试助手连续发送三条信息，代码运行都够收到以后，程序并未退出这个时候就做到了持续等待收数据和信息的效果。</p></blockquote>\n<p>学习了 udp 收发数据以后，可以做一个基于 udp 的简单聊天器了，这个聊天器是发一句收一句的，因为还没有采取多线程的处理方式。具体代码如下，这个时候就不需要调试助手来充当角色了：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import socket\n\ndef send_msg(udp_scoket,dest_ip,dest_port):\n    &quot;&quot;&quot;&quot;发送消息&quot;&quot;&quot;\n    #获取要发送的内容\n    send_data&#x3D;input(&quot;请输入要发送的消息:&quot;)\n    udp_scoket.sendto(send_data.encode(&quot;gbk&quot;), (dest_ip, int(dest_port)))\n\n\ndef recv_msg(udp_scoket):\n    &quot;&quot;&quot;&quot;接收消息&quot;&quot;&quot;\n    recv_data&#x3D;udp_scoket.recvfrom(1024)\n    print(&quot;%s回消息说:%s&quot; %(str(recv_data[1]),recv_data[0].decode(&quot;gbk&quot;)))\n\n\ndef main():\n    #创建套接字\n    udp_scoket&#x3D;socket.socket(socket.AF_INET,socket.SOCK_DGRAM)\n\n    #绑定信息\n    #绑定的是一个元组，里面存放ip信息和端口信息\n    udp_scoket.bind((&quot;&quot;,7788))\n    # 确定对方地址\n    dest_ip &#x3D; input(&quot;请输入对方的ip:&quot;)\n    dest_port &#x3D; input(&quot;请输入对方的port:&quot;)\n\n    #循环发送接收消息\n    while True:\n            #发送\n            send_msg(udp_scoket,dest_ip,dest_port)\n\n            #接受并显示\n            recv_msg(udp_scoket)\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()</code></pre>\n\n<p>这里测试自己收发<br>程序运行如下：<br><img src=\"https://img-blog.csdnimg.cn/20190108150039481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以看出是做到了自己收发消息了的，即在一个程序里，自己发送数据给自己自己接收数据并打印显示，当然也可以用两份程序分别演示一个发送数据，一个接收数据。具体看自己怎么理解和操作。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>下一次记录 tcp 的有关知识和实践</p></blockquote>\n", "text": " python 高级学习日志第二、三天之网络编程UDP 接收数据以及基于 UDP 的交易聊天器 一个 Java 程序员，但是打算自学一下 python，所以把自己学到的东西记录在这里。也免得我自己忘记新学的，年纪大了真的很容易忘东西。 哈哈，我喜欢边写程序边听歌 上次记录的是怎么...", "link": "", "photos": [], "count_time": {"symbolsCount": "4.3k", "symbolsTime": "4 mins."}, "categories": [{"name": "Python", "slug": "Python", "count": 2, "path": "api/categories/Python.json"}], "tags": [{"name": "Python网络编程", "slug": "Python网络编程", "count": 2, "path": "api/tags/Python网络编程.json"}], "toc": "<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#python-%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E7%AC%AC%E4%BA%8C%E3%80%81%E4%B8%89%E5%A4%A9%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">python 高级学习日志第二、三天之网络编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#UDP-%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%8F%8A%E5%9F%BA%E4%BA%8E-UDP-%E7%9A%84%E4%BA%A4%E6%98%93%E8%81%8A%E5%A4%A9%E5%99%A8\"><span class=\"toc-text\">UDP 接收数据以及基于 UDP 的交易聊天器</span></a></li></ol></li></ol>", "author": {"name": "倪传方", "slug": "blog-author", "avatar": "/img/site/avatar.webp", "link": "/", "description": "一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>", "socials": {"github": "https://github.com/nichuanfang", "twitter": "https://twitter.com/jayzhouzj", "stackoverflow": "https://stackoverflow.com/users/12083298/jaychou", "wechat": "", "qq": "", "weibo": "", "zhihu": "https://www.zhihu.com/people/ba-dao-yi-shan-zhu", "csdn": "https://blog.csdn.net/Saphroth", "juejin": "https://juejin.cn/user/2740456686366830", "customs": {}}}, "mapped": true}}