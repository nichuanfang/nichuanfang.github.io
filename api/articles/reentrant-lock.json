{"title":"可重入锁ReentrantLock高级特性","uid":"2e5004b8a8ff49317aa7f3e9b71f74cf","slug":"reentrant-lock","date":"2023-05-07T23:05:39.000Z","updated":"2023-05-11T12:44:16.971Z","comments":true,"path":"api/articles/reentrant-lock.json","keywords":null,"cover":"/img/reentrant-lock/reentrant-lock.jpg","content":"<h2 id=\"ReentrantLock提供了Synchronized不具备的三个高级特性\"><a href=\"#ReentrantLock提供了Synchronized不具备的三个高级特性\" class=\"headerlink\" title=\"ReentrantLock提供了Synchronized不具备的三个高级特性\"></a><code>ReentrantLock</code>提供了<code>Synchronized</code>不具备的三个高级特性</h2><ul>\n<li>公平锁</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * Creates an instance of &#123;@code ReentrantLock&#125;.\n * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.\n *&#x2F;\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync(); \n&#125;</code></pre>\n\n<ul>\n<li>等待可中断</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 尝试锁定\n *\n * @param timeout 超时时间\n * @param unit    单位\n * @return boolean 尝试获取锁的结果\n * @throws InterruptedException 中断异常\n *&#x2F;\npublic boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n&#125;</code></pre>\n\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>条件通知,一把锁可以生成多个条件,每个条件可以对应一个线程分组,可以通过condition对象来进行分组等待和唤醒,解决了<code>synchronized</code>关键字只能<code>notifyAll()</code>的问题</p>\n</div>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Condition newCondition() &#123;\n    return sync.newCondition();\n&#125;</code></pre>\n\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">注意</p>\n<p><code>ReentrantLock</code>条件通知使用注意点</p>\n</div>\n<ul>\n<li>每个condition可以绑定若干个线程,如果需要多个condition请先对线程进行分组;</li>\n<li>使用<code>await()</code>和<code>signal()</code>或者<code>signalAll()</code>之前需要先获取锁,在finally代码块中要释放锁;</li>\n</ul>\n<h2 id=\"实战演示\"><a href=\"#实战演示\" class=\"headerlink\" title=\"实战演示\"></a>实战演示</h2><p>模拟三个线程,对其中两个线程分为一组绑定到<code>condition1</code>,剩下的一个线程单独一组绑定到<code>condition2</code>,main线程再分别唤醒等待状态的各线程组.</p>\n<ul>\n<li>创建线程池</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final ThreadFactory threadFactory &#x3D; ThreadFactoryBuilder.create().setNamePrefix(&quot;test&quot;).build();\n\nprivate final Executor executor &#x3D; new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() + 1, Runtime.getRuntime().availableProcessors() + 1,\n        10, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(16), threadFactory, new ThreadPoolExecutor.AbortPolicy());</code></pre>\n\n<ul>\n<li>初始化<code>CountDownLatch</code>和<code>ReentrantLock</code>,注册两个<code>condition</code>.</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;闭锁1  让3个子线程同时启动\nCountDownLatch startCdl &#x3D; new CountDownLatch(1);\n&#x2F;&#x2F;闭锁2  main线程等待子线程都执行完毕再结束\nCountDownLatch endCdl &#x3D; new CountDownLatch(3);\n&#x2F;&#x2F;同步锁\nReentrantLock lock &#x3D; new ReentrantLock(false);\n\nCondition condition1 &#x3D; lock.newCondition();\nCondition condition2 &#x3D; lock.newCondition();</code></pre>\n\n<ul>\n<li>创建子线程,进入等待状态,等主线程唤醒</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 获取线程\n *\n * @param startCdl       开始同步器\n * @param endCdl         结束同步器\n * @param lock      锁\n * @param condition 条件\n * @return &#123;@link Thread&#125;\n *&#x2F;\nprivate Runnable getCallable(CountDownLatch startCdl, CountDownLatch endCdl, ReentrantLock lock, Condition condition) &#123;\n    return () -&gt; &#123;\n        try &#123;\n            &#x2F;&#x2F;让三个子线程同时启动\n            startCdl.await();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n        lock.lock();\n        try &#123;\n            &#x2F;&#x2F;await会释放当前锁\n            condition.await();\n            log.info(&quot;线程&#123;&#125;被唤醒,时间:&#123;&#125;&quot;, Thread.currentThread().getName(),new Date());\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            log.info(&quot;线程:&#123;&#125;执行完毕,释放同步锁&quot;,Thread.currentThread().getName());\n            &#x2F;&#x2F;被唤醒后,需要释放当前持有的锁\n            lock.unlock();\n            &#x2F;&#x2F;计数器为0主线程停止等待\n            endCdl.countDown();\n        &#125;\n    &#125;;\n&#125;\n&#x2F;&#x2F;启动三个子线程\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl ,lock, condition1));\nexecutor.execute(getCallable(startCdl,endCdl,lock, condition2));</code></pre>\n\n<ul>\n<li>主线程进行唤醒</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">log.info(&quot;Main线程开始执行....&quot;);\nstartCdl.countDown();\nlog.info(&quot;子线程正在等待....&quot;);\n\nlock.lock();\ncondition1.signalAll();\nlock.unlock();\ntry &#123;\n    &#x2F;&#x2F;主线程阻塞2秒 区分两次唤醒\n    Thread.sleep(2000);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;\nlock.lock();\ncondition2.signal();\nlock.unlock();\ntry &#123;\n    log.info(&quot;等待三个子线程执行完毕&quot;);\n    endCdl.await();\n    log.info(&quot;main线程结束&quot;);\n&#125; catch (InterruptedException e) &#123;\n    e.printStackTrace();\n&#125;</code></pre>\n\n<ul>\n<li>控制台输出. 可以看出两次唤醒相隔了两秒<br><img src=\"/img/reentrant-lock/reentrant-lock-test.png\" alt=\"alt\"></li>\n</ul>\n","feature":true,"text":"ReentrantLock提供了Synchronized不具备的三个高级特性 公平锁 &#x2F;** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using ...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"可重入锁","slug":"可重入锁","count":1,"path":"api/categories/可重入锁.json"}],"tags":[{"name":"ReentrantLock","slug":"ReentrantLock","count":1,"path":"api/tags/ReentrantLock.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ReentrantLock%E6%8F%90%E4%BE%9B%E4%BA%86Synchronized%E4%B8%8D%E5%85%B7%E5%A4%87%E7%9A%84%E4%B8%89%E4%B8%AA%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">ReentrantLock提供了Synchronized不具备的三个高级特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%88%98%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">实战演示</span></a></li></ol>","author":{"name":"倪传方","slug":"blog-author","avatar":"/img/site/avatar.jpg","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>","socials":{"github":"https://github.com/nichuanfang","twitter":"https://twitter.com/jayzhouzj","stackoverflow":"https://stackoverflow.com/users/12083298/jaychou","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/ba-dao-yi-shan-zhu","csdn":"https://blog.csdn.net/Saphroth","juejin":"https://juejin.cn/user/2740456686366830","customs":{}}},"mapped":true,"prev_post":{"title":"个人简历","uid":"1269f6284fcda69dd94df081174c6509","slug":"resume","date":"2023-05-09T23:18:05.000Z","updated":"2023-05-11T12:44:16.971Z","comments":true,"path":"api/articles/resume.json","keywords":null,"cover":"/img/resume.png","text":"欢迎使用在线 Vditor Markdown 编辑器vditor 是一款浏览器端的 Markdown 编辑器，支持所见即所得、即时渲染（类似 Typora）和分屏预览模式。它使用 TypeScript 实现，支持原生 JavaScript、Vue、React 和 Angular。...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"简历","slug":"简历","count":1,"path":"api/categories/简历.json"}],"tags":[{"name":"resume","slug":"resume","count":1,"path":"api/tags/resume.json"}],"author":{"name":"倪传方","slug":"blog-author","avatar":"/img/site/avatar.jpg","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>","socials":{"github":"https://github.com/nichuanfang","twitter":"https://twitter.com/jayzhouzj","stackoverflow":"https://stackoverflow.com/users/12083298/jaychou","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/ba-dao-yi-shan-zhu","csdn":"https://blog.csdn.net/Saphroth","juejin":"https://juejin.cn/user/2740456686366830","customs":{}}},"feature":true},"next_post":{}}