{"title": "有关Docker容器架构", "uid": "c1b8e397764a04b15b42b94eec3a8f01", "slug": "有关Docker容器架构", "date": "2022-03-22 10:29:00", "updated": "2023-05-16 18:26:43.205000", "comments": true, "path": "api/articles/有关Docker容器架构.json", "keywords": null, "cover": [], "content": "<meta name=\"referrer\" content=\"no-referrer\" />\n\n<h2 id=\"有关Docker容器架构\"><a href=\"#有关Docker容器架构\" class=\"headerlink\" title=\"有关Docker容器架构\"></a>有关Docker容器架构</h2><p><img src=\"https://img-blog.csdnimg.cn/20190408110120125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Docker客户端与服务器<br>Docker是一个客户端-服务器的（C&#x2F;S）架构程序，Docker的客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具和一整套RESTful API。你可以在同一台主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。<br><img src=\"https://img-blog.csdnimg.cn/20190408110539327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Docker镜像<br>镜像（Image）是Docker中的一个模板。通过Docker镜像来创建Docker容器，一个镜像可以创造出多个容器。镜像是由一系列指令一步一步构建出来，例如：</p></blockquote>\n<ol>\n<li>添加一个文件</li>\n<li>执行一个命令</li>\n<li>打开一个窗口</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>j镜像与容器的关系类似于java中类与对象的关系镜像体积很小，非常“便携”，易于分享，存储和更新。</p></blockquote>\n<table>\n<thead>\n<tr>\n<th>Docker</th>\n<th>Java</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>镜像</td>\n<td>类</td>\n</tr>\n<tr>\n<td>容器</td>\n<td>对象</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Emp&#123;&#125; &#x2F;&#x2F;镜像：\nEmp e1 &#x3D; new Emp(); &#x2F;&#x2F;容器1\nEmp e2 &#x3D; new Emp(); &#x2F;&#x2F;容器2</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Docker容器<br>容器（Container）是基于镜像创建的运行的实例，一个容器中可以运行一个或者多个应用程序（jdk+开发的java应用程序）。<br>Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。<br>可以认为，镜像是Docker生命周期的构建或者打包阶段，而容器则是启动或者执行阶段。<br><strong>可以理解容器中有包含：一个精简版的Linux环境+要运行的应用程序</strong></p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Docker仓库<br>仓库（Repository）是集中存放镜像文件的场所。<br>有时候会把仓库（Repository）和仓库注册服务器（Registry）混为一谈，但并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。<br>仓库分为公有仓库（Public）和私有仓库（Private）两种。<br>Docker公司运营的公共仓库叫做 Docker Hub （<a href=\"https://hub.docker.com/%EF%BC%89%EF%BC%8C%E5%AD%98%E6%94%BE%E4%BA%86%E6%95%B0%E9%87%8F%E5%BA%9E%E5%A4%A7%E7%9A%84%E9%95%9C%E5%83%8F%E4%BE%9B%E7%94%A8%E6%88%B7%E4%B8%8B%E8%BD%BD%E3%80%82%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E5%9C%A8Docker\">https://hub.docker.com/），存放了数量庞大的镜像供用户下载。用户可以在Docker</a> Hub注册账号，分享并保存自己的镜像。（说明：在Docker Hub下载镜像巨慢）<br>国内的公有仓库包括阿里云 、网易云 等，可以提供大陆用户更稳定快速的访问。<br>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。<br>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p></blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20190408112040550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQ4Nzk1,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n", "text": " 有关Docker容器架构 Docker客户端与服务器Docker是一个客户端-服务器的（C&#x2F;S）架构程序，Docker的客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具和一整套RESTf...", "link": "", "photos": [], "count_time": {"symbolsCount": "1.2k", "symbolsTime": "1 mins."}, "categories": [{"name": "Devops", "slug": "Devops", "count": 1, "path": "api/categories/Devops.json"}], "tags": [{"name": "Docker", "slug": "Docker", "count": 1, "path": "api/tags/Docker.json"}], "toc": "<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%85%B3Docker%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">有关Docker容器架构</span></a></li></ol>", "author": {"name": "倪传方", "slug": "blog-author", "avatar": "/img/site/avatar.webp", "link": "/", "description": "一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>", "socials": {"github": "https://github.com/nichuanfang", "twitter": "https://twitter.com/jayzhouzj", "stackoverflow": "https://stackoverflow.com/users/12083298/jaychou", "wechat": "", "qq": "", "weibo": "", "zhihu": "https://www.zhihu.com/people/ba-dao-yi-shan-zhu", "csdn": "https://blog.csdn.net/Saphroth", "juejin": "https://juejin.cn/user/2740456686366830", "customs": {}}}, "mapped": true, "prev_post": {"title": "python高级学习日志第二、三天之网络编程", "uid": "e266b70dd1da3efc040f3fd65a612a8c", "slug": "python高级学习日志第二、三天之网络编程", "date": "2022-10-01 09:29:00", "updated": "2023-05-16 18:26:43.205000", "comments": true, "path": "api/articles/python高级学习日志第二、三天之网络编程.json", "keywords": null, "cover": [], "text": " python高级学习日志第二、三天之网络编程UDP接收数据以及基于UDP的交易聊天器 一个Java程序员，但是打算自学一下python，所以把自己学到的东西记录在这里。也免得我自己忘记新学的，年纪大了真的很容易忘东西。 哈哈，我喜欢边写程序边听歌 上次记录的是怎么用udp来发送...", "link": "", "photos": [], "count_time": {"symbolsCount": "4.2k", "symbolsTime": "4 mins."}, "categories": [{"name": "Python", "slug": "Python", "count": 2, "path": "api/categories/Python.json"}], "tags": [{"name": "Python网络编程", "slug": "Python网络编程", "count": 2, "path": "api/tags/Python网络编程.json"}], "author": {"name": "倪传方", "slug": "blog-author", "avatar": "/img/site/avatar.webp", "link": "/", "description": "一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>", "socials": {"github": "https://github.com/nichuanfang", "twitter": "https://twitter.com/jayzhouzj", "stackoverflow": "https://stackoverflow.com/users/12083298/jaychou", "wechat": "", "qq": "", "weibo": "", "zhihu": "https://www.zhihu.com/people/ba-dao-yi-shan-zhu", "csdn": "https://blog.csdn.net/Saphroth", "juejin": "https://juejin.cn/user/2740456686366830", "customs": {}}}, "mapped": true}, "next_post": {"title": "jvm学习笔记之类的加载、连接与初始化——2019-04-04", "uid": "12fca0e747f267a1a8595589f1ccd75b", "slug": "jvm学习笔记之类的加载、连接与初始化——2019-04-04", "date": "2021-07-09 11:39:11", "updated": "2023-05-16 18:26:43.205000", "comments": true, "path": "api/articles/jvm学习笔记之类的加载、连接与初始化——2019-04-04.json", "keywords": null, "cover": [], "content": "<meta name=\"referrer\" content=\"no-referrer\" />\n\n<h3 id=\"jvm学习笔记之类的加载、连接与初始化——2019-04-04\"><a href=\"#jvm学习笔记之类的加载、连接与初始化——2019-04-04\" class=\"headerlink\" title=\"jvm学习笔记之类的加载、连接与初始化——2019-04-04\"></a>jvm学习笔记之类的加载、连接与初始化——2019-04-04</h3><h4 id=\"类的加载、连接与初始化\"><a href=\"#类的加载、连接与初始化\" class=\"headerlink\" title=\"类的加载、连接与初始化\"></a>类的加载、连接与初始化</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>加载：查找并加载类的二进制数据</li>\n<li>连接<ol>\n<li>验证：确保被加载类的正确性</li>\n<li>准备：为类的静态变量分配内存，并将其初始化为默认值</li>\n<li>解析：把类中的符号引用转换为直接引用</li>\n</ol>\n</li>\n<li>初始化：为类的静态变量赋予正确的初始值</li>\n</ol></blockquote>\n<p>如：<br>Class test{<br>     Public static int a&#x3D;1;<br>}<br>在test类在被加载时，静态变量a首先被分配内存，设置默认值a&#x3D;0<br>接着在初始化过程中才被赋予正确的初始值a&#x3D;1</p>\n<p>Java程序对类的使用方式可分为两种</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>主动使用<br>被动使用</p></blockquote>\n<p>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们</p>\n<p>主动使用（七种）<br> 创建类的实例（new一个类对象）<br> 访问某个类或接口的静态变量，或者对该静态变量赋值（对静态变量取值赋值）<br>助记符 getstatic  putstatic<br> 调用类的静态方法  助记符 invokestatic<br> 反射（如Class.forName(“com.test.Test”)）<br> 初始化一个类的子类<br>如：<br>Class Parent{}<br>Class Child extends Parent{}<br>当子类被初始化时，同时也标记着父类的主动使用，父类也会被初始化<br> Java虚拟机启动时被标明为启动类的类（Java Test）<br> JDK1.7开始提供的动态语言支持<br>Java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化</p>\n<p>除了以上七种情况，其它使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化</p>\n<p>类的加载<br>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，大致上放在堆区，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构</p>\n<p> 加载.class文件的方式</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 从本地系统中直接加载（ide工作区重启加载项目即是如此）<br> 通过网络下载.class文件<br> 从zip，jar等归档文件中加载.class文件<br> 从专有数据库中提取.class文件<br> 将Java源文件动态编译为.class文件（如JSP中java代码的编写，实际上是转化成了Servlet）</p></blockquote>\n<p>（主动使用）<br>测试代码一</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lagoon.jvm.classloder;\n\npublic class MyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyChild1.str);\n    &#125;\n&#125;\n\nclass MyParent1&#123;\n\n    public static String str&#x3D;&quot;hello world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent1 static block&quot;);\n    &#125;\n&#125;\n\nclass MyChild1 extends MyParent1&#123;\n    static &#123;\n        System.out.println(&quot;MyChild1 static block&quot;);\n    &#125;\n&#125;\n</code></pre>\n\n<p>测试结果<br><img src=\"https://img-blog.csdnimg.cn/20190404225143742.png\" alt=\"在这里插入图片描述\"></p>\n<p>并没有输出MyChild1 static block<br>这种情况称之为对MyParent1的一个主动使用，但是并没有对MyChild1进行主动使用<br>所以并不会对MyChild1进行初始化，也就不会执行静态代码块</p>\n<p>测试代码二</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lagoon.jvm.classloder;\n\npublic class MyTest1 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyChild1.str2);\n    &#125;\n&#125;\n\nclass MyParent1&#123;\n\n    public static String str&#x3D;&quot;hello world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent1 static block&quot;);\n    &#125;\n&#125;\n\nclass MyChild1 extends MyParent1&#123;\n    public static String str2&#x3D;&quot;welcome...&quot;;\n    static &#123;\n        System.out.println(&quot;MyChild1 static block&quot;);\n    &#125;\n&#125;\n</code></pre>\n\n<p>测试结果<br><img src=\"https://img-blog.csdnimg.cn/20190404225229276.png\" alt=\"在这里插入图片描述\"></p>\n<p>此时在MyChild1中定义了一个str2，并在main方法中调用的str2，是对MyChild类的一次主动使用，自然会初始化，自然也就会执行静态代码块，输出语句<br>而对于为什么MyParent1也会输出语句？<br>是因为主动使用里有一条<br>出初始化一个类的子类，那么也就是这个父类也会被主动使用，进行一次初始化。<br>父类会进行先行初始化</p>\n<p>测试总结：<br>对于一个静态字段来说，只有直接定义了该字段的类才会被初始化<br>当一个类在初始化时，要求其父类全部都已经初始化完毕<br>这就是问什么输出语句有先后顺序</p>\n<p>有关jvm虚拟机vm设置指令</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">-XX:+TraceClassLoading,用于追踪类的加载信息并打印出来\n -XX:+&lt;option&gt;，表示开启option选项\n -XX:-&lt;option&gt;，表示关闭option选项\n*-XX:&lt;option&gt;&#x3D;&lt;value&gt;，表示将option的值设置为value</code></pre>\n\n<p>再新建一个测试类MyTest2</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.lagoon.jvm.classloder;\n\npublic class MyTest2 &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(MyParent2.str);\n    &#125;\n&#125;\nclass MyParent2&#123;\n    public static String str&#x3D;&quot;hello,world&quot;;\n\n    static &#123;\n        System.out.println(&quot;MyParent2 static block&quot;);\n    &#125;\n&#125;\n</code></pre>\n\n<p>测试结果<br><img src=\"https://img-blog.csdnimg.cn/20190404225411357.png\" alt=\"在这里插入图片描述\"></p>\n<p>显而易见是在MyParent2里定义了静态字段，<br>所以会对这个类进行初始化，运行静态代码块<br>但是如果把</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static  String str&#x3D;&quot;hello,world&quot;;</code></pre>\n\n<p>改成</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static final String str&#x3D;&quot;hello,world&quot;;</code></pre>\n\n<p>加上关键字final<br>运行结果如下<br><img src=\"https://img-blog.csdnimg.cn/20190404225519784.png\" alt=\"在这里插入图片描述\"></p>\n<p>产生这种差异的原因是</p>\n<p>final本身的作用在于str被定义以后不能再被改变，str成为常量，<br>然而常量在编译阶段，会被直接存入到调用这个常量的方法所在类（MyTest2）的常量池中<br>之后，MyTest2与MyParent2就没有任何的关系了</p>\n<p>因此本质上，调用类，也就是MyTest2，并没有直接引用到定义这个常量的类，也就是<br>MyParent2，因此不会触发定义常量的类的初始化</p>\n<p>对MyTest2进行反编译后如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190404225538165.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>助记符：<br>ldc表示将int，float或是String类型的常量值从常量池中推送至栈顶</p></blockquote>\n", "text": " jvm学习笔记之类的加载、连接与初始化——2019-04-04类的加载、连接与初始化 加载：查找并加载类的二进制数据 连接 验证：确保被加载类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转换为直接引用 初始化：为类的静态变量赋予正确的初始...", "link": "", "photos": [], "count_time": {"symbolsCount": "3.5k", "symbolsTime": "3 mins."}, "categories": [{"name": "Java", "slug": "Java", "count": 2, "path": "api/categories/Java.json"}], "tags": [{"name": "jvm", "slug": "jvm", "count": 1, "path": "api/tags/jvm.json"}], "toc": "<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%94%E2%80%942019-04-04\"><span class=\"toc-text\">jvm学习笔记之类的加载、连接与初始化——2019-04-04</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">类的加载、连接与初始化</span></a></li></ol></li></ol>", "author": {"name": "倪传方", "slug": "blog-author", "avatar": "/img/site/avatar.webp", "link": "/", "description": "一位正在重塑知识的技术人 <br /> @ <b>微信：ncf08209270</b>", "socials": {"github": "https://github.com/nichuanfang", "twitter": "https://twitter.com/jayzhouzj", "stackoverflow": "https://stackoverflow.com/users/12083298/jaychou", "wechat": "", "qq": "", "weibo": "", "zhihu": "https://www.zhihu.com/people/ba-dao-yi-shan-zhu", "csdn": "https://blog.csdn.net/Saphroth", "juejin": "https://juejin.cn/user/2740456686366830", "customs": {}}}, "mapped": true}}