<!DOCTYPE html>
<html data-default-color-scheme="auto" lang="zh-CN"><head><meta charset="utf-8"/><link href="/img/fluid.png" rel="apple-touch-icon" sizes="76x76"/><link href="/img/fluid.png" rel="icon"/><meta content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no" name="viewport"/><meta content="ie=edge" http-equiv="x-ua-compatible"/><meta content="upgrade-insecure-requests" http-equiv="Content-Security-Policy"/><meta content="#2f4154" name="theme-color"/><meta content="Nichuanfang" name="author"/><meta content="" name="keywords"/><meta content="让我们先对 Go（或称 Golang ）做一个小小的介绍。Go 是由谷歌工程师 Robert Griesemer、Rob Pike 和 Ken Thompson设计的。它是一种静态类型的、编译的语言。第一个版本于 2012 年 3 月作为开源版本发布。在许多编程语言中，有许多方法来解决一个特定的问题。程序员要花很多时间去思考解决它的最佳方法。Go却相信用较少的功能——只有" name="description"/><meta content="article" property="og:type"/><meta content="go学习" property="og:title"/><meta content="https://blog.jaychou.site/2023/12/02/go%E5%AD%A6%E4%B9%A0/index.html" property="og:url"/><meta content="个人博客" property="og:site_name"/><meta content="让我们先对 Go（或称 Golang ）做一个小小的介绍。Go 是由谷歌工程师 Robert Griesemer、Rob Pike 和 Ken Thompson设计的。它是一种静态类型的、编译的语言。第一个版本于 2012 年 3 月作为开源版本发布。在许多编程语言中，有许多方法来解决一个特定的问题。程序员要花很多时间去思考解决它的最佳方法。Go却相信用较少的功能——只有" property="og:description"/><meta content="zh_CN" property="og:locale"/><meta content="https://blog.jaychou.site/img/post/go%E5%AD%A6%E4%B9%A0/banner.webp" property="og:image"/><meta content="2023-12-02T09:22:33.000Z" property="article:published_time"/><meta content="2023-12-27T13:59:04.000Z" property="article:modified_time"/><meta content="Nichuanfang" property="article:author"/><meta content="go" property="article:tag"/><meta content="summary_large_image" name="twitter:card"/><meta content="https://blog.jaychou.site/img/post/go%E5%AD%A6%E4%B9%A0/banner.webp" name="twitter:image"/><title>go学习 - 个人博客</title><link href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" rel="stylesheet"/><link href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" rel="stylesheet"/><link href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" rel="stylesheet"/><link href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css" rel="stylesheet"/><link href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css" rel="stylesheet"/><link href="/css/main.css" rel="stylesheet"/><link href="/css/highlight.css" id="highlight-css" rel="stylesheet"/><link href="/css/highlight-dark.css" id="highlight-css-dark" rel="stylesheet"/><link href="/css/culture.css" rel="stylesheet"/><link href="/css/custom.css" rel="stylesheet"/><link href="/css/APlayer.min.css" rel="stylesheet"/><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"blog.jaychou.site",root:"/",version:"1.9.5",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!1,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:0},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><link href="/css/all.min.css" rel="stylesheet"/><script src="/js/culture_init.js"></script><script src="/js/culture/movie.js"></script><script src="/js/culture/movie_detail.js"></script><meta content="Hexo 7.0.0" name="generator"/></head><body><div id="background-image" style="display:none;left:330.067px"><img alt="Background image" lazyload="" src="/img/bg/bg01.png" srcset="/img/loading.gif"/></div><header><div class="header-inner" style="height:62vh"><nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar" id="navbar"><div class="container"><a class="navbar-brand" href="/"><strong>文森特 World</strong> </a><button aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#navbarSupportedContent" data-toggle="collapse" id="navbar-toggler-btn" type="button"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/culture/" target="_self"><i class="iconfont icon-music"></i> <span>文艺</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a aria-label="Search" class="nav-link" data-target="#modalSearch" data-toggle="modal" href="javascript:;" target="_self"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a aria-label="Color Toggle" class="nav-link" href="javascript:;" target="_self"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div class="banner" false="" id="banner" style="background:url(/img/post/go%E5%AD%A6%E4%B9%A0/banner.webp) no-repeat center 30%;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,0)"><div class="banner-text text-center fade-in-up"><div class="h2"><span data-typed-text="go学习" id="subtitle"></span></div><div class="mt-3"><span class="post-meta"><i aria-hidden="true" class="iconfont icon-date-fill"></i> <time datetime="2023-12-02 17:22" pubdate="">2023年12月2日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 36 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">go学习</h1><div class="markdown-body"><div class="note note-success"><p>让我们先对 Go（或称 Golang ）做一个小小的介绍。Go 是由谷歌工程师 Robert Griesemer、Rob Pike 和 Ken Thompson<br/>设计的。它是一种静态类型的、编译的语言。第一个版本于 2012 年 3 月作为开源版本发布。在许多编程语言中，有许多方法来解决一个特定的问题。程序员要花很多时间去思考解决它的最佳方法。Go<br/>却相信用较少的功能——只有一种正确的方式来解决问题,这为开发人员节省了时间，并使大型代码库易于维护。 Go 中没有像 <code>maps</code><br/>和 <code>filters</code> 这样的 “表达性”功能。</p></div><blockquote><ul><li>“Go 是一种开源的编程语言，它使人们能够轻松地构建简单、可靠和高效的软件”。- GoLang</li><li>“当你有增加表现力的功能时，通常会增加系统开销”—— Rob Pike</li></ul></blockquote><p><img alt="1*AUiSG5Gqz8MzaGCvGpckGA" lazyload="" src="https://cdn-media-1.freecodecamp.org/images/1*AUiSG5Gqz8MzaGCvGpckGA.png" srcset="/img/loading.gif"/></p><h3 id="入门"><a class="headerlink" href="#入门" title="入门"></a>入门</h3><p>Go 是由 packages（包）组成的。package main 告诉 Go 编译器，该程序被编译为可执行文件，而不是共享库。它是一个应用程序的入口点。package<br/>main 的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br/></code></pre></td></tr></table></figure><p>让我们继续前进，在 Go workspace 创建一个 <code>main.go</code> 文件，编写一个简单的 hello world 例子。</p><h4 id="Workspace"><a class="headerlink" href="#Workspace" title="Workspace"></a><strong>Workspace</strong></h4><p>Go 中的 workspace 是由环境变量 <code>GOPATH</code> 定义的。</p><p>你写的任何代码都要写在 workspace 里面。Go 将搜索 <code>GOPATH</code> 目录内的任何软件包，或者 <code>GOROOT</code> 目录，该目录在安装 Go<br/>时默认设置。<code>GOROOT</code> 是安装 Go 的路径。</p><p>设置 <code>GOPATH</code> 到你想要的目录。现在，让我们把它添加到 <code>~/workspace</code> 文件夹内。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">export</span> <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span> GOPATH=~/workspace</span><br/><span class="hljs-meta prompt_"></span><br/><span class="hljs-meta prompt_"># </span><span class="language-bash">go inside the workspace directory <span class="hljs-built_in">cd</span> ~/workspace</span><br/></code></pre></td></tr></table></figure><p>在我们刚刚创建的 workspace 文件夹中创建 <code>main.go</code> 文件，其中包含以下代码。</p><h4 id="Hello-World"><a class="headerlink" href="#Hello-World" title="Hello World"></a>Hello World</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> )<br/><br/><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br/>  fmt.Println(<span class="hljs-string">"Hello World!"</span>)<br/>}<br/></code></pre></td></tr></table></figure><p>在上面的例子中，<code>fmt</code>是 Go 中的一个内置包，它实现了用于格式化 I/O 输出的函数。</p><p>我们通过使用 <code>import</code> 关键字在 Go 中导入一个包。<code>func main</code> 是代码被执行的主入口点。<code>Println</code> 是包 <code>fmt</code> 中的一个函数，它为我们打印出<br/>“hello world”。</p><p>让我们通过运行这个文件来看看。我们有两种方法可以运行 Go 命令。正如我们所知，Go 是一种编译语言，所以我们首先需要在执行之前编译它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">go build main.go</span><br/></code></pre></td></tr></table></figure><p>这将创建一个二进制可执行文件<code>main</code>，现在我们可以运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">./main <span class="hljs-comment"># Hello World!</span></span><br/></code></pre></td></tr></table></figure><p>还有一种更简单的方法来运行程序。<code>go run</code> 命令会编译源代码，并直接执行源码中的 main() 函数，不会在当前目录留下可执行文件。你可以简单地运行以下命令来执行该程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell">go run main.go # Hello World!<br/></code></pre></td></tr></table></figure><p>**<em>注意</em>**：<em>要尝试本博客中提到的代码，你可以使用 <a href="https://play.golang.org/" rel="noopener" target="_blank">https://play.golang.org</a></em></p><h3 id="变量"><a class="headerlink" href="#变量" title="变量"></a>变量</h3><p>Go 中的变量是明确声明的。Go 是一种静态类型的语言。这意味着在声明变量的时候会检查变量的类型。一个变量可以被声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br/></code></pre></td></tr></table></figure><p>在这种情况下，值将被设置为 0。使用下面的语法来声明和初始化一个具有不同值的变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br/></code></pre></td></tr></table></figure><p>这里的变量被自动分配为 int。我们可以对变量的声明使用一个简短定义，即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">message := <span class="hljs-string">"hello world"</span><br/></code></pre></td></tr></table></figure><p>我们也可以在同一行中声明多个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b, c <span class="hljs-type">int</span> = <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br/></code></pre></td></tr></table></figure><h3 id="数据类型"><a class="headerlink" href="#数据类型" title="数据类型"></a>数据类型</h3><p>像其他编程语言一样，Go 支持各种不同的数据结构。让我们来探索其中：</p><h4 id="整型、字符串和布尔值"><a class="headerlink" href="#整型、字符串和布尔值" title="整型、字符串和布尔值"></a>整型、字符串和布尔值</h4><p>支持的整型包括 int, int8, int16, int32, int64,<br/>uint, uint8, uint16, uint32, uint64, uintptr(无符号整型，长度跟平台相关，它的长度可以用来保存一个指针地址) 等</p><p>字符串类型存储一个字节序列。它用关键字 <code>string</code> 来表示和声明。</p><p>布尔值使用关键字 <code>bool</code> 来存储。</p><p>Go 也支持复数类型，可以用 <code>complex64</code> 和 <code>complex128</code> 来声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br/><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br/><span class="hljs-keyword">var</span> c <span class="hljs-type">string</span> = <span class="hljs-string">'hello world'</span><br/><span class="hljs-keyword">var</span> d <span class="hljs-type">float32</span> = <span class="hljs-number">1.222</span><br/><span class="hljs-keyword">var</span> x <span class="hljs-type">complex128</span> = cmplx.Sqrt(<span class="hljs-number">-5</span> + <span class="hljs-number">12i</span>)<br/></code></pre></td></tr></table></figure><h4 id="数组、切片和-Maps"><a class="headerlink" href="#数组、切片和-Maps" title="数组、切片和 Maps"></a>数组、切片和 Maps</h4><p>数组是由相同数据类型的元素组成的一个序列。数组在声明时有一个固定的长度，所以它不能被扩大到超过这个长度。一个数组声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br/></code></pre></td></tr></table></figure><p>数组也可以是多维的。我们可以简单地用以下方式创建它们：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> multiD [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br/></code></pre></td></tr></table></figure><p>数组会限制数组的值发生变化，当代码运行时。数组也没有提供获取子数组的能力。 为此，Go有一种数据类型，叫做切片（slices）。</p><p>切片存储了一连串的元素，并且可以在任何时候扩展。切片声明与数组声明类似——但没有定义容量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b []<span class="hljs-type">int</span><br/></code></pre></td></tr></table></figure><p>这将创建一个容量为 0、长度为 0 的切片。</p><p>也可以用容量和长度来定义切片。我们可以用下面的语法来定义它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">numbers := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br/></code></pre></td></tr></table></figure><p>这里，切片的初始长度为 5，容量为 10。</p><p>分片是对数组的一种抽象。切片使用一个数组作为底层结构。一个片断包含三个部分：容量、长度和一个指向底层数组的指针，如下图所示：</p><p><img alt="1*P0lNCO0sQwIYHLEX_mfSOQ" lazyload="" src="https://cdn-media-1.freecodecamp.org/images/1*P0lNCO0sQwIYHLEX_mfSOQ.png" srcset="/img/loading.gif"/></p><p>图片源自: <a href="https://blog.golang.org/go-slices-usage-and-internals" rel="noopener" target="_blank">https://blog.golang.org/go-slices-usage-and-internals</a></p><p>一个切片的容量可以通过使用 append 或 copy 函数来增加。append 函数将值添加到数组的末端，如果需要的话也可以增加容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br/></code></pre></td></tr></table></figure><p>另一种增加切片容量的方法是使用 copy 函数。简单地创建另一个容量更大的片断，并将原来的切片复制到新创建的切片上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// create a new slice number2 := make([]int, 15)</span><br/><br/><span class="hljs-comment">// copy the original slice to new slice copy(number2, number)</span><br/></code></pre></td></tr></table></figure><p>我们可以创建一个切片的子切片。这可以通过以下命令简单地完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initialize a slice with 4 len and values number2 = []int{1,2,3,4} fmt.Println(numbers)</span><br/><span class="hljs-comment">// -&gt; [1 2 3 4]</span><br/><span class="hljs-comment">// create sub slices slice1 := number2[2:] fmt.Println(slice1)</span><br/><span class="hljs-comment">// -&gt; [3 4] slice2 := number2[:3] fmt.Println(slice2)</span><br/><span class="hljs-comment">// -&gt; [1 2 3] slice3 := number2[1:4] fmt.Println(slice3)</span><br/><span class="hljs-comment">// -&gt; [2 3 4]</span><br/></code></pre></td></tr></table></figure><p>Maps 是 Go 中的一种数据类型，它将键映射到值。我们可以使用以下命令来定义一个 map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br/></code></pre></td></tr></table></figure><p><code>m</code> 是新的 map 变量，它的键是 <code>string</code> 类型， 值是 <code>integers</code> 类型。我们很容易在 map 上添加键值对：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// adding key/value m['clearity'] = 2 m['simplicity'] = 3</span><br/><span class="hljs-comment">// printing the values fmt.Println(m['clearity'])</span><br/><span class="hljs-comment">// -&gt; 2 fmt.Println(m['simplicity'])</span><br/><span class="hljs-comment">// -&gt; 3</span><br/></code></pre></td></tr></table></figure><h3 id="类型转换"><a class="headerlink" href="#类型转换" title="类型转换"></a>类型转换</h3><p>一种类型的数据类型可以通过类型转换转换为另一种类型。让我们看看一个简单的类型转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">1.1</span> b := <span class="hljs-type">int</span>(a) fmt.Println(b)<br/><span class="hljs-comment">//-&gt; 1</span><br/></code></pre></td></tr></table></figure><p>不是所有类型的数据类型都可以转换为另一种类型。请确保数据类型与转换的内容相匹配。</p><h3 id="条件语句"><a class="headerlink" href="#条件语句" title="条件语句"></a>条件语句</h3><h4 id="if-else"><a class="headerlink" href="#if-else" title="if else"></a>if else</h4><p>对于条件性语句，我们可以使用 if-else 语句，如下例所示。请确保大括号与条件语句在同一行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> num := <span class="hljs-number">9</span>; num &lt; <span class="hljs-number">0</span> { fmt.Println(num, <span class="hljs-string">"is negative"</span>) }<br/> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">10</span> { fmt.Println(num, <span class="hljs-string">"has 1 digit"</span>) } <span class="hljs-keyword">else</span> { fmt.Println(num, <span class="hljs-string">"has multiple digits"</span>) }<br/></code></pre></td></tr></table></figure><h4 id="switch-case"><a class="headerlink" href="#switch-case" title="switch case"></a>switch case</h4><p>Switch cases 有助于组织多个条件语句。下面的例子显示了一个简单的 siwtch 语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">2</span> <span class="hljs-keyword">switch</span> i { <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: fmt.Println(<span class="hljs-string">"one"</span>) <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: fmt.Println(<span class="hljs-string">"two"</span>) <span class="hljs-keyword">default</span>: fmt.Println(<span class="hljs-string">"none"</span>) }<br/></code></pre></td></tr></table></figure><h3 id="循环"><a class="headerlink" href="#循环" title="循环"></a>循环</h3><p>Go 有一个循环的关键词 <code>for</code>。<code>for</code> 循环命令用于实现不同种类的循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">0</span> sum := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> { sum += <span class="hljs-number">1</span> i++ } fmt.Println(sum)<br/></code></pre></td></tr></table></figure><p>上面的例子类似于 C 语言中的 while 循环。</p><p>Go 中的 for 语句也可以用于普通的 for 循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">sum := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ { sum += i } fmt.Println(sum)<br/></code></pre></td></tr></table></figure><p>Go 中的死循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> { }<br/></code></pre></td></tr></table></figure><h3 id="Pointers-（指针）"><a class="headerlink" href="#Pointers-（指针）" title="Pointers （指针）"></a>Pointers （指针）</h3><p>Go提供了指针。指针是用来保存一个值的地址的地方。指针是由 * 定义的。指针是根据数据的类型来定义的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ap *<span class="hljs-type">int</span><br/></code></pre></td></tr></table></figure><p><code>ap</code> 是指向一个整数类型的指针。<code>&amp;</code> 操作符可以用来获取一个变量的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">12</span> ap = &amp;a<br/></code></pre></td></tr></table></figure><p>指针所指向的值可以使用 <code>*</code> 操作符来访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(*ap) <span class="hljs-comment">// =&gt; 12</span><br/></code></pre></td></tr></table></figure><p>在传递结构体作为参数时，或者在为定义的类型声明方法时，通常倾向于使用指针。</p><ol><li>传递值时，实际上是在复制值，这意味着更多的内存。</li><li>通过指针，函数改变的值会反映在 方法/函数 调用者身上</li></ol><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(i *<span class="hljs-type">int</span>)</span></span> { *i++ } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { i := <span class="hljs-number">10</span> increment(&amp;i) fmt.Println(i) } <span class="hljs-comment">//=&gt; 11</span><br/></code></pre></td></tr></table></figure><p>注意：当你在尝试博客中的示例代码时，不要忘记用 <code>package main</code> 包含它，并在需要时导入 fmt 或其他包，如上面第一个 main.go<br/>例子中所示。</p><h3 id="Functions-（函数）"><a class="headerlink" href="#Functions-（函数）" title="Functions （函数）"></a>Functions （函数）</h3><p>在 main package 中定义的 main 函数是 go 程序执行的入口。更多的函数可以被定义和使用。让我们来看看一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> { c := a + b <span class="hljs-keyword">return</span> c } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { fmt.Println(add(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)) } <span class="hljs-comment">//=&gt; 3</span><br/></code></pre></td></tr></table></figure><p>在上面的例子中我们可以看到，Go 函数是用 <strong>func</strong> 关键字来定义的，后面是函数名称。一个函数的 <strong>参数</strong><br/>需要根据其数据类型来定义，最后是返回的数据类型。</p><p>一个函数的返回值也可以在函数中预先定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (c <span class="hljs-type">int</span>) { c = a + b <span class="hljs-keyword">return</span> } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { fmt.Println(add(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)) } <span class="hljs-comment">//=&gt; 3</span><br/></code></pre></td></tr></table></figure><p>这里c被定义为返回变量。所以定义的变量c会自动返回，而不需要在最后的返回语句中定义。</p><p>你也可以从一个函数中返回多个返回值，用逗号来分隔返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">string</span>) { c := a + b <span class="hljs-keyword">return</span> c, <span class="hljs-string">"successfully added"</span> } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { sum, message := add(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) fmt.Println(message) fmt.Println(sum) }<br/></code></pre></td></tr></table></figure><h3 id="方法、结构体、接口"><a class="headerlink" href="#方法、结构体、接口" title="方法、结构体、接口"></a>方法、结构体、接口</h3><p>Go并不是一种完全面向对象的语言，但通过结构体（Struct）、接口（Interface）和方法（Method），它有很多面向对象的支持和感觉。</p><h4 id="结构体（Struct）"><a class="headerlink" href="#结构体（Struct）" title="结构体（Struct）"></a>结构体（Struct）</h4><p>结构体是一种类型化的、不同字段的集合。结构体用于将数据分组。例如，如果我们想对 Person<br/>类型的数据进行分组，我们可以定义一个人的属性，其中可能包括姓名、年龄、性别。可以使用以下语法来定义一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> { name <span class="hljs-type">string</span> age <span class="hljs-type">int</span> gender <span class="hljs-type">string</span> }<br/></code></pre></td></tr></table></figure><p>在定义了一个人的类型结构后，现在让我们来创建一个 person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//way 1: specifying attribute and value p = person{name: "Bob", age: 42, gender: "Male"} //way 2: specifying only value person{"Bob", 42, "Male"}</span><br/></code></pre></td></tr></table></figure><p>我们可以很容易地用一个点（.）来访问这些数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">p.name <span class="hljs-comment">//=&gt; Bob p.age //=&gt; 42 p.gender //=&gt; Male</span><br/></code></pre></td></tr></table></figure><p>你也可以用结构的指针直接访问其属性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">pp = &amp;person{name: <span class="hljs-string">"Bob"</span>, age: <span class="hljs-number">42</span>, gender: <span class="hljs-string">"Male"</span>} pp.name <span class="hljs-comment">//=&gt; Bob</span><br/></code></pre></td></tr></table></figure><h4 id="方法（Methods）"><a class="headerlink" href="#方法（Methods）" title="方法（Methods）"></a>方法（Methods）</h4><p>方法（Method）是一种特殊的函数类型，它有一个 <em>receiver</em> 。<em>receiver</em> 可以是一个值或一个指针。让我们创建一个名为 describe<br/>的方法（Method），它有一个我们在上面的例子中创建的接收器类型的 person：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span> <span class="hljs-comment">// struct defination type person struct { name string age int gender string } // method defination func (p *person) describe() { fmt.Printf("%v is %v years old.", p.name, p.age) } func (p *person) setAge(age int) { p.age = age } func (p person) setName(name string) { p.name = name } func main() { pp := &amp;person{name: "Bob", age: 42, gender: "Male"} pp.describe() // =&gt; Bob is 42 years old pp.setAge(45) fmt.Println(pp.age) //=&gt; 45 pp.setName("Hari") fmt.Println(pp.name) //=&gt; Bob }</span><br/></code></pre></td></tr></table></figure><p>正如我们在上面的例子中看到的，现在可以使用点运算符来调用该方法，如 <code>pp.describe</code>。请注意，<em>receiver</em><br/>是一个指针。使用指针，我们传递的是一个值的引用，所以如果我们在方法中做任何改变，都会反映在 <em>receiver</em><br/>pp中。它也不会创建一个新的对象的副本，这就节省了内存。</p><p>请注意，在上面的例子中，年龄的值被改变了，而名字的值没有改变，因为setName方法是 <em>receiver</em> 类型的，而 setAge 是指针类型的。</p><h4 id="接口（Interfaces）"><a class="headerlink" href="#接口（Interfaces）" title="接口（Interfaces）"></a>接口（Interfaces）</h4><p>Go 接口（interfaces）是一个方法（methods）的集合。接口有助于将一个类型的属性组合在一起。让我们以一个接口 animal 为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> { description() <span class="hljs-type">string</span> }<br/></code></pre></td></tr></table></figure><p>animal 是一个接口（interface）类型。现在让我们创建两个不同类型的 animal，它们都实现了 animal 接口类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> ) <span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> { description() <span class="hljs-type">string</span> } <span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> { Type <span class="hljs-type">string</span> Sound <span class="hljs-type">string</span> } <span class="hljs-keyword">type</span> snake <span class="hljs-keyword">struct</span> { Type <span class="hljs-type">string</span> Poisonous <span class="hljs-type">bool</span> } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s snake)</span></span> description() <span class="hljs-type">string</span> { <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"Poisonous: %v"</span>, s.Poisonous) } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span></span> description() <span class="hljs-type">string</span> { <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">"Sound: %v"</span>, c.Sound) } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { <span class="hljs-keyword">var</span> a animal a = snake{Poisonous: <span class="hljs-literal">true</span>} fmt.Println(a.description()) a = cat{Sound: <span class="hljs-string">"Meow!!!"</span>} fmt.Println(a.description()) } <span class="hljs-comment">//=&gt; Poisonous: true //=&gt; Sound: Meow!!!</span><br/></code></pre></td></tr></table></figure><p>type cat struct {<br/>在主函数中，我们创建一个动物类型的变量 <code>a</code>。我们给动物分配一个 snake 和一个 cat 的类型，并使用 Println 来打印<br/>a.description。由于我们在两种类型（cat 和 snake）中都以不同的方式实现了 describe 方法，我们得到了打印的动物描述。</p><h3 id="包"><a class="headerlink" href="#包" title="包"></a>包</h3><p>我们把Go的所有代码都写在一个包里。<strong>main</strong> package 是程序执行的入口点。Go 中有很多内置包。我们一直在使用的最著名的是<strong>fmt</strong><br/>包。</p><blockquote><p>“Go 软件包是 Go 提供的大型编程的主要机制，它们使得将一个大型项目分割成小块成为可能。”<br/>— Robert Griesemer</p></blockquote><h4 id="Installing-a-package-安装一个包"><a class="headerlink" href="#Installing-a-package-安装一个包" title="Installing a package (安装一个包)"></a>Installing a package (安装一个包)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell">go get &lt;package-url-github&gt; // example go get github.com/satori/go.uuid<br/></code></pre></td></tr></table></figure><p>我们安装的软件包被保存在 GOPATH 环境变量设置的工作目录。你可以通过进入我们工作目录下的 pkg 文件夹 <code>cd $GOPATH/pkg</code><br/>来查看这些软件包。</p><h4 id="创建自定义包"><a class="headerlink" href="#创建自定义包" title="创建自定义包"></a>创建自定义包</h4><p>让我们先创建一个文件夹 custom_package：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> custom_package &gt; <span class="hljs-built_in">cd</span> custom_package</span><br/></code></pre></td></tr></table></figure><p>要创建一个自定义包，我们需要首先创建一个文件夹，并加上我们需要的包名。比方说，我们要建立一个 <code>person</code><br/>包。为此，让我们在 <code>custom_package</code> 文件夹中创建一个名为 <code>person</code> 的文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> person &gt; <span class="hljs-built_in">cd</span> person</span><br/></code></pre></td></tr></table></figure><p>现在让我们在这个文件夹中创建一个文件 person.go。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> person <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Description</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"The person name is: "</span> + name } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">secretName</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> { <span class="hljs-keyword">return</span> <span class="hljs-string">"Do not share"</span> }<br/></code></pre></td></tr></table></figure><p>我们现在需要安装这个包，以便它可以被导入和使用。因此，让我们来安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">go install</span><br/></code></pre></td></tr></table></figure><p>现在让我们回到custom_package文件夹，创建一个 main.go 文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span>( <span class="hljs-string">"custom_package/person"</span> <span class="hljs-string">"fmt"</span> ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{ p := person.Description(<span class="hljs-string">"Milap"</span>) fmt.Println(p) } <span class="hljs-comment">// =&gt; The person name is: Milap</span><br/></code></pre></td></tr></table></figure><p>在这里，我们现在可以导入我们创建的包 <code>person</code> 并使用函数 Description。注意，我们在包中创建的函数 <code>secretName</code> 将不能被访问。在<br/>Go 中，没有大写字母开头的方法名称将是私有的。</p><h4 id="包文档"><a class="headerlink" href="#包文档" title="包文档"></a>包文档</h4><p>Go内置了对包的文档支持。运行以下命令来生成文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell">godoc person Description<br/></code></pre></td></tr></table></figure><p>这将为我们的包 person 里面的描述函数生成文档。要看到这些文档，请使用以下命令运行一个网络服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs shell">godoc -http=":8080"<br/></code></pre></td></tr></table></figure><p>现在去URL <a href="http://localhost:6060/pkg/" rel="noopener" target="_blank">http://localhost:8080/pkg/</a>，看看我们刚刚创建的包的文档。</p><h4 id="Go-内置包"><a class="headerlink" href="#Go-内置包" title="Go 内置包"></a>Go 内置包</h4><p><strong>fmt</strong></p><p>该包实现了格式化的 I/O 函数。我们已经用这个包实现了向 stdout 打印的功能。</p><p><strong>json</strong></p><p>Go中另一个有用的包是json包。这有助于对JSON进行编码/解码。让我们举个例子，对一些 JSON 进行编码/解码：</p><p>编码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> <span class="hljs-string">"encoding/json"</span> ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{ mapA := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>{<span class="hljs-string">"apple"</span>: <span class="hljs-number">5</span>, <span class="hljs-string">"lettuce"</span>: <span class="hljs-number">7</span>} mapB, _ := json.Marshal(mapA) fmt.Println(<span class="hljs-type">string</span>(mapB)) }<br/></code></pre></td></tr></table></figure><p>解码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> <span class="hljs-string">"encoding/json"</span> ) <span class="hljs-keyword">type</span> response <span class="hljs-keyword">struct</span> { PageNumber <span class="hljs-type">int</span> <span class="hljs-string">`json:"page"`</span> Fruits []<span class="hljs-type">string</span> <span class="hljs-string">`json:"fruits"`</span> } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{ str := <span class="hljs-string">`{"page": 1, "fruits": ["apple", "peach"]}`</span> res := response{} json.Unmarshal([]<span class="hljs-type">byte</span>(str), &amp;res) fmt.Println(res.PageNumber) } <span class="hljs-comment">//=&gt; 1</span><br/></code></pre></td></tr></table></figure><p>当使用 unmarshal 解码 json 字节时，第一个参数是 json 字节，第二个参数是我们希望 json<br/>被映射到的响应类型结构的地址。注意，<code>json: "page"</code>将页面键映射到结构中的 PageNumber 键。</p><h3 id="错误处理"><a class="headerlink" href="#错误处理" title="错误处理"></a>错误处理</h3><p>错误是指程序中不想要的和意外的结果。比方说，我们正在对一个外部服务进行 API 调用。这个 API 调用可能是成功的，也可能是失败的。当错误类型出现时，Go<br/>程序中的错误可以被识别。让我们看看这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">resp, err := http.Get(<span class="hljs-string">"http://example.com/"</span>)<br/></code></pre></td></tr></table></figure><p>在这里，对错误对象的 API 调用可能通过也可能失败。我们可以检查错误是否为零或存在，并相应地处理响应：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> <span class="hljs-string">"net/http"</span> ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{ resp, err := http.Get(<span class="hljs-string">"http://example.com/"</span>) <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> { fmt.Println(err) <span class="hljs-keyword">return</span> } fmt.Println(resp) }<br/></code></pre></td></tr></table></figure><h4 id="从函数返回自定义错误"><a class="headerlink" href="#从函数返回自定义错误" title="从函数返回自定义错误"></a>从函数返回自定义错误</h4><p>当我们在编写自己的函数时，有些情况下会出现错误。这些错误可以在错误对象的帮助下返回：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Increment</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) { <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> { <span class="hljs-comment">// return error object return nil, errors.New("math: cannot process negative number") } return (n + 1), nil } func main() { num := 5 if inc, err := Increment(num); err != nil { fmt.Printf("Failed Number: %v, error message: %v", num, err) }else { fmt.Printf("Incremented Number: %v", inc) } }</span><br/></code></pre></td></tr></table></figure><p>大多数 Go 中内置的包，或者我们使用的外部包，都有一个错误处理的机制。所以我们调用的任何函数都有可能出现错误。这些错误绝不应该被忽视，总是在我们调用这些函数的地方优雅地处理，正如我们在上面的例子中所做的那样。</p><h4 id="Panic"><a class="headerlink" href="#Panic" title="Panic"></a>Panic</h4><p>Panic 是指在程序执行过程中突然遇到的未被处理的东西。在Go中，Panic 不是处理程序中异常的理想方式。建议使用一个错误对象来代替。当<br/>Panic 发生时，程序的执行会被停止。Panic 发生后被执行的东西是 defer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Go package main import "fmt" func main() { f() fmt.Println("Returned normally from f.") } func f() { defer func() { if r := recover(); r != nil { fmt.Println("Recovered in f", r) } }() fmt.Println("Calling g.") g(0) fmt.Println("Returned normally from g.") } func g(i int) { if i &gt; 3 { fmt.Println("Panicking!") panic(fmt.Sprintf("%v", i)) } defer fmt.Println("Defer in g", i) fmt.Println("Printing in g", i) g(i + 1) }</span><br/></code></pre></td></tr></table></figure><h4 id="Defer"><a class="headerlink" href="#Defer" title="Defer"></a>Defer</h4><p>Defer 是指总是在函数的末尾被执行的东西。</p><p>在上面的例子中，我们用 panic() 使程序的执行陷入 panic。正如你所注意到的，这里有一个 defer<br/>语句，它将使程序在最后执行这一行。当我们需要在函数结束时执行一些东西时也可以使用 defer，例如关闭一个文件。</p><h3 id="并发"><a class="headerlink" href="#并发" title="并发"></a>并发</h3><p>Go 是在考虑到并发性的情况下建立的。Go 中的并发性可以通过 Go 协程实现，它是轻量级的线程。</p><p><strong>Go 协程</strong></p><p>Go 协程是可以与另一个函数并行或同时运行的函数。创建一个 Go 协程非常简单。只需在一个函数前面加上关键字 Go，我们就可以让它并行执行。Go<br/>协程是非常轻量级的，所以我们可以创建成千上万的协程。让我们来看看一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> <span class="hljs-string">"time"</span> ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { <span class="hljs-keyword">go</span> c() fmt.Println(<span class="hljs-string">"I am main"</span>) time.Sleep(time.Second * <span class="hljs-number">2</span>) } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span> { time.Sleep(time.Second * <span class="hljs-number">2</span>) fmt.Println(<span class="hljs-string">"I am concurrent"</span>) } <span class="hljs-comment">//=&gt; I am main //=&gt; I am concurrent</span><br/></code></pre></td></tr></table></figure><p>正如你在上面的例子中所看到的，函数 c 是一个 Go 协程，与 Go 主线程并行执行。有些时候，我们希望在多个线程之间共享资源。Go<br/>倾向于不将一个线程的变量与另一个线程共享，因为这样会增加死锁和资源等待的可能性。还有一种方法可以在 Go 协程之间共享资源：通过<br/>Go channels。</p><p><strong>通道</strong></p><p>我们可以使用通道在两个 Go 协程之间传递数据。在创建 channel 时，有必要指定该 channel 接收什么样的数据。让我们创建一个简单的字符串类型的<br/>channel，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br/></code></pre></td></tr></table></figure><p>通过这个 channel，我们可以发送字符串类型的数据。我们可以在这个 channel 中发送和接收数据:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{ c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{ c &lt;- <span class="hljs-string">"hello"</span> }() msg := &lt;-c fmt.Println(msg) } <span class="hljs-comment">//=&gt;"hello"</span><br/></code></pre></td></tr></table></figure><p>接收方 channel 等待，直到发送方发送数据到 channel。</p><p><strong>单向通道</strong></p><p>有些情况下，我们希望 Go 程序通过 channel 接收数据，但不发送数据，反之亦然。为此，我们也可以创建一个<strong>单向 channel</strong><br/>。让我们来看看一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) <span class="hljs-keyword">go</span> sc(ch) fmt.Println(&lt;-ch) } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sc</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> { ch &lt;- <span class="hljs-string">"hello"</span> }<br/></code></pre></td></tr></table></figure><p>在上面的例子中，<code>sc</code> 是一个 Go 协程，它只能向通道发送消息，但不能接收消息。</p><h3 id="使用-select-为-Go-例程组织多个通道"><a class="headerlink" href="#使用-select-为-Go-例程组织多个通道" title="使用 select 为 Go 例程组织多个通道"></a>使用 select 为 Go 例程组织多个通道</h3><p>一个函数可能有多个 channel 在等待。为此，我们可以使用一个选择（select）语句。让我们看一个例子，以了解更清楚的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> ( <span class="hljs-string">"fmt"</span> <span class="hljs-string">"time"</span> ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> { c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) <span class="hljs-keyword">go</span> speed1(c1) <span class="hljs-keyword">go</span> speed2(c2) fmt.Println(<span class="hljs-string">"The first to arrive is:"</span>) <span class="hljs-keyword">select</span> { <span class="hljs-keyword">case</span> s1 := &lt;-c1: fmt.Println(s1) <span class="hljs-keyword">case</span> s2 := &lt;-c2: fmt.Println(s2) } } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speed1</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> { time.Sleep(<span class="hljs-number">2</span> * time.Second) ch &lt;- <span class="hljs-string">"speed 1"</span> } <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">speed2</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> { time.Sleep(<span class="hljs-number">1</span> * time.Second) ch &lt;- <span class="hljs-string">"speed 2"</span> }<br/></code></pre></td></tr></table></figure><p>在上面的例子中，main正在等待两个 channel，c1 和 c2。通过 select case 语句，main 函数打印出，信息从它先收到的 channel 中发送出来。</p><p><strong>带缓冲的通道</strong></p><p>你可以在go中创建一个缓冲 channel。有了缓冲 channel，如果缓冲区满了，发送到该 channel 的消息就会被阻断。让我们看一下这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{ ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">2</span>) ch &lt;- <span class="hljs-string">"hello"</span> ch &lt;- <span class="hljs-string">"world"</span> ch &lt;- <span class="hljs-string">"!"</span> # extra message in buffer fmt.Println(&lt;-ch) } <span class="hljs-comment">// =&gt; fatal error: all goroutines are asleep - deadlock!</span><br/></code></pre></td></tr></table></figure><p>正如我们在上面看到的，一个 channel 接受的信息不超过2条。</p><h4 id="为什么-Golang-会成功？"><a class="headerlink" href="#为什么-Golang-会成功？" title="为什么 Golang 会成功？"></a>为什么 Golang 会成功？</h4><blockquote><p>简洁性… — Rob-pike</p></blockquote><h3 id="Great"><a class="headerlink" href="#Great" title="Great"></a>Great</h3><p>我们学习了 Go 的一些主要组成部分和特点。</p><ol><li>变量、数据类型</li><li>数组 切片 和 maps</li><li>函数</li><li>循环和条件语句</li><li>指针</li><li>软件包</li><li>方法、结构体和接口</li><li>错误处理</li><li>并发 - Go 协程和通道</li></ol><p>恭喜你，你现在对 Go 有了相当的了解。</p><blockquote><p>我最有成效的一天是减少了 1000 行代码。<br/>— Ken Thompson</p></blockquote><p>不要停在这里，继续向前推进，思考一个小的应用并开始创建。</p><p><a href="https://www.linkedin.com/in/milap-neupane-99a4b565/" rel="noopener" target="_blank">LinkedIn</a><br/><a href="http://github.com/milap-neupane" rel="noopener" target="_blank">Github</a><br/><a href="https://twitter.com/_milap" rel="noopener" target="_blank">Twitter</a></p><p>我也在 Milap Neupane<br/>博客发布本文：<a href="https://milapneupane.com.np/2019/07/06/learning-golang-from-zero-to-hero/" rel="noopener" target="_blank">学习Go，从0到1</a></p></div><hr/><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a class="category-chain-item" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="print-no-link" href="/tags/go/">#go</a></div><div class="post-meta" style="margin-left: auto"><a class="print-no-link" href="https://github.com/nichuanfang/hexo-blog/edit/main/posts/go学习/index.md" target="_blank"><span aria_label="hexo-blog" class="hint--top hint--rounded" style="color: #007bff"><i class="iconfont icon-pen">在Github上编辑本页</i></span></a></div></div><div class="license-box my-3"><div class="license-title"><div>go学习</div><div>https://blog.jaychou.site/2023/12/02/go学习/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Nichuanfang</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年12月2日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2023年12月27日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" href="https://creativecommons.org/licenses/by/4.0/" target="_blank"><span aria-label="BY - 署名" class="hint--top hint--rounded"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/12/02/hello-world/" title="hello-world"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">hello-world</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/12/02/music-tool-kit%E5%B7%A5%E5%85%B7/" title="music-tool-kit工具"><span class="hidden-mobile">music-tool-kit工具</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload=""><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var i=Object.assign({appId:"enOFHBl7E8Mh2ZLlcjZ679m0-gzGzoHsz",appKey:"eZI7IWrl3Nq2PqR3CLZhsqTg",path:"window.location.pathname",placeholder:"说点什么吧...",avatar:"mp",meta:["nick","mail","link"],requiredFields:["nick"],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!1,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a aria-label="TOP" href="#" id="scroll-top-button" role="button"><i aria-hidden="true" class="iconfont icon-arrowup"></i></a><div aria-hidden="true" aria-labelledby="ModalLabel" class="modal fade" id="modalSearch" role="dialog" tabindex="-1"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button aria-label="Close" class="close" data-dismiss="modal" id="local-search-close" type="button"><span aria-hidden="true">×</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input class="form-control validate" id="local-search-input" type="text"/> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><div class="col-lg-7 mx-auto nopadding-x-md"><div class="container custom mx-auto"><div id="aplayer"></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet"/><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/side_bg.js"></script><script src="/js/APlayer.min.js"></script><script src="/js/useaplayer.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>